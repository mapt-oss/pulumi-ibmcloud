// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class ContainerCluster extends pulumi.CustomResource {
    /**
     * Get an existing ContainerCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ContainerClusterState, opts?: pulumi.CustomResourceOptions): ContainerCluster {
        return new ContainerCluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ibmcloud:index/containerCluster:ContainerCluster';

    /**
     * Returns true if the given object is an instance of ContainerCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ContainerCluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ContainerCluster.__pulumiType;
    }

    declare public /*out*/ readonly albs: pulumi.Output<outputs.ContainerClusterAlb[]>;
    /**
     * CRN of resource instance
     */
    declare public /*out*/ readonly crn: pulumi.Output<string>;
    /**
     * The datacenter where this cluster will be deployed
     */
    declare public readonly datacenter: pulumi.Output<string>;
    /**
     * The size of the default worker pool
     */
    declare public readonly defaultPoolSize: pulumi.Output<number | undefined>;
    /**
     * disc encryption done, if set to true.
     */
    declare public readonly diskEncryption: pulumi.Output<boolean | undefined>;
    /**
     * Entitlement option reduces additional OCP Licence cost in Openshift Clusters
     */
    declare public readonly entitlement: pulumi.Output<string | undefined>;
    /**
     * Force the removal of a cluster and its persistent storage. Deleted data cannot be recovered
     */
    declare public readonly forceDeleteStorage: pulumi.Output<boolean | undefined>;
    /**
     * Set true for gateway enabled clusters
     */
    declare public readonly gatewayEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Hardware type
     */
    declare public readonly hardware: pulumi.Output<string>;
    /**
     * Set true to enable image security enforcement policies
     */
    declare public readonly imageSecurityEnforcement: pulumi.Output<boolean | undefined>;
    declare public /*out*/ readonly ingressHostname: pulumi.Output<string>;
    declare public /*out*/ readonly ingressSecret: pulumi.Output<string>;
    /**
     * Enables KMS on a given cluster
     */
    declare public readonly kmsConfig: pulumi.Output<outputs.ContainerClusterKmsConfig | undefined>;
    /**
     * Kubernetes version info
     */
    declare public readonly kubeVersion: pulumi.Output<string>;
    /**
     * list of labels to the default worker pool
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string}>;
    /**
     * Machine type
     */
    declare public readonly machineType: pulumi.Output<string | undefined>;
    /**
     * The cluster name
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Boolean value set to true when subnet creation is not required.
     */
    declare public readonly noSubnet: pulumi.Output<boolean | undefined>;
    /**
     * The operating system of the workers in the default worker pool.
     */
    declare public readonly operatingSystem: pulumi.Output<string>;
    /**
     * Kubernetes patch version
     */
    declare public readonly patchVersion: pulumi.Output<string | undefined>;
    /**
     * Custom subnet CIDR to provide private IP addresses for pods
     */
    declare public readonly podSubnet: pulumi.Output<string>;
    declare public readonly privateServiceEndpoint: pulumi.Output<boolean>;
    declare public /*out*/ readonly privateServiceEndpointUrl: pulumi.Output<string>;
    /**
     * Private VLAN ID
     */
    declare public readonly privateVlanId: pulumi.Output<string | undefined>;
    declare public readonly publicServiceEndpoint: pulumi.Output<boolean>;
    declare public /*out*/ readonly publicServiceEndpointUrl: pulumi.Output<string>;
    /**
     * Public VLAN ID
     */
    declare public readonly publicVlanId: pulumi.Output<string | undefined>;
    /**
     * The cluster region
     *
     * @deprecated This field is deprecated
     */
    declare public readonly region: pulumi.Output<string>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about this cluster
     */
    declare public /*out*/ readonly resourceControllerUrl: pulumi.Output<string>;
    /**
     * The crn of the resource
     */
    declare public /*out*/ readonly resourceCrn: pulumi.Output<string>;
    /**
     * ID of the resource group.
     */
    declare public readonly resourceGroupId: pulumi.Output<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    declare public /*out*/ readonly resourceGroupName: pulumi.Output<string>;
    /**
     * The name of the resource
     */
    declare public /*out*/ readonly resourceName: pulumi.Output<string>;
    /**
     * The status of the resource
     */
    declare public /*out*/ readonly resourceStatus: pulumi.Output<string>;
    /**
     * Argument which helps to retry the patch version updates on worker nodes. Increment the value to retry the patch updates if the previous apply fails
     */
    declare public readonly retryPatchVersion: pulumi.Output<number | undefined>;
    declare public /*out*/ readonly serverUrl: pulumi.Output<string>;
    /**
     * Custom subnet CIDR to provide private IP addresses for services
     */
    declare public readonly serviceSubnet: pulumi.Output<string>;
    /**
     * List of subnet IDs
     */
    declare public readonly subnetIds: pulumi.Output<string[] | undefined>;
    /**
     * Tags for the resource
     */
    declare public readonly tags: pulumi.Output<string[]>;
    /**
     * WorkerPool Taints
     */
    declare public readonly taints: pulumi.Output<outputs.ContainerClusterTaint[] | undefined>;
    /**
     * Updates all the woker nodes if sets to true
     */
    declare public readonly updateAllWorkers: pulumi.Output<boolean | undefined>;
    /**
     * Wait for worker node to update during kube version update.
     */
    declare public readonly waitForWorkerUpdate: pulumi.Output<boolean | undefined>;
    /**
     * wait_till can be configured for Master Ready, One worker Ready, Ingress Ready or Normal
     */
    declare public readonly waitTill: pulumi.Output<string | undefined>;
    declare public readonly webhooks: pulumi.Output<outputs.ContainerClusterWebhook[] | undefined>;
    declare public /*out*/ readonly workerPools: pulumi.Output<outputs.ContainerClusterWorkerPool[]>;
    /**
     * The IDs of the worker node
     */
    declare public readonly workersInfos: pulumi.Output<outputs.ContainerClusterWorkersInfo[]>;

    /**
     * Create a ContainerCluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ContainerClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ContainerClusterArgs | ContainerClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ContainerClusterState | undefined;
            resourceInputs["albs"] = state?.albs;
            resourceInputs["crn"] = state?.crn;
            resourceInputs["datacenter"] = state?.datacenter;
            resourceInputs["defaultPoolSize"] = state?.defaultPoolSize;
            resourceInputs["diskEncryption"] = state?.diskEncryption;
            resourceInputs["entitlement"] = state?.entitlement;
            resourceInputs["forceDeleteStorage"] = state?.forceDeleteStorage;
            resourceInputs["gatewayEnabled"] = state?.gatewayEnabled;
            resourceInputs["hardware"] = state?.hardware;
            resourceInputs["imageSecurityEnforcement"] = state?.imageSecurityEnforcement;
            resourceInputs["ingressHostname"] = state?.ingressHostname;
            resourceInputs["ingressSecret"] = state?.ingressSecret;
            resourceInputs["kmsConfig"] = state?.kmsConfig;
            resourceInputs["kubeVersion"] = state?.kubeVersion;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["machineType"] = state?.machineType;
            resourceInputs["name"] = state?.name;
            resourceInputs["noSubnet"] = state?.noSubnet;
            resourceInputs["operatingSystem"] = state?.operatingSystem;
            resourceInputs["patchVersion"] = state?.patchVersion;
            resourceInputs["podSubnet"] = state?.podSubnet;
            resourceInputs["privateServiceEndpoint"] = state?.privateServiceEndpoint;
            resourceInputs["privateServiceEndpointUrl"] = state?.privateServiceEndpointUrl;
            resourceInputs["privateVlanId"] = state?.privateVlanId;
            resourceInputs["publicServiceEndpoint"] = state?.publicServiceEndpoint;
            resourceInputs["publicServiceEndpointUrl"] = state?.publicServiceEndpointUrl;
            resourceInputs["publicVlanId"] = state?.publicVlanId;
            resourceInputs["region"] = state?.region;
            resourceInputs["resourceControllerUrl"] = state?.resourceControllerUrl;
            resourceInputs["resourceCrn"] = state?.resourceCrn;
            resourceInputs["resourceGroupId"] = state?.resourceGroupId;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["resourceName"] = state?.resourceName;
            resourceInputs["resourceStatus"] = state?.resourceStatus;
            resourceInputs["retryPatchVersion"] = state?.retryPatchVersion;
            resourceInputs["serverUrl"] = state?.serverUrl;
            resourceInputs["serviceSubnet"] = state?.serviceSubnet;
            resourceInputs["subnetIds"] = state?.subnetIds;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["taints"] = state?.taints;
            resourceInputs["updateAllWorkers"] = state?.updateAllWorkers;
            resourceInputs["waitForWorkerUpdate"] = state?.waitForWorkerUpdate;
            resourceInputs["waitTill"] = state?.waitTill;
            resourceInputs["webhooks"] = state?.webhooks;
            resourceInputs["workerPools"] = state?.workerPools;
            resourceInputs["workersInfos"] = state?.workersInfos;
        } else {
            const args = argsOrState as ContainerClusterArgs | undefined;
            if (args?.datacenter === undefined && !opts.urn) {
                throw new Error("Missing required property 'datacenter'");
            }
            if (args?.hardware === undefined && !opts.urn) {
                throw new Error("Missing required property 'hardware'");
            }
            resourceInputs["datacenter"] = args?.datacenter;
            resourceInputs["defaultPoolSize"] = args?.defaultPoolSize;
            resourceInputs["diskEncryption"] = args?.diskEncryption;
            resourceInputs["entitlement"] = args?.entitlement;
            resourceInputs["forceDeleteStorage"] = args?.forceDeleteStorage;
            resourceInputs["gatewayEnabled"] = args?.gatewayEnabled;
            resourceInputs["hardware"] = args?.hardware;
            resourceInputs["imageSecurityEnforcement"] = args?.imageSecurityEnforcement;
            resourceInputs["kmsConfig"] = args?.kmsConfig;
            resourceInputs["kubeVersion"] = args?.kubeVersion;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["machineType"] = args?.machineType;
            resourceInputs["name"] = args?.name;
            resourceInputs["noSubnet"] = args?.noSubnet;
            resourceInputs["operatingSystem"] = args?.operatingSystem;
            resourceInputs["patchVersion"] = args?.patchVersion;
            resourceInputs["podSubnet"] = args?.podSubnet;
            resourceInputs["privateServiceEndpoint"] = args?.privateServiceEndpoint;
            resourceInputs["privateVlanId"] = args?.privateVlanId;
            resourceInputs["publicServiceEndpoint"] = args?.publicServiceEndpoint;
            resourceInputs["publicVlanId"] = args?.publicVlanId;
            resourceInputs["region"] = args?.region;
            resourceInputs["resourceGroupId"] = args?.resourceGroupId;
            resourceInputs["retryPatchVersion"] = args?.retryPatchVersion;
            resourceInputs["serviceSubnet"] = args?.serviceSubnet;
            resourceInputs["subnetIds"] = args?.subnetIds;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["taints"] = args?.taints;
            resourceInputs["updateAllWorkers"] = args?.updateAllWorkers;
            resourceInputs["waitForWorkerUpdate"] = args?.waitForWorkerUpdate;
            resourceInputs["waitTill"] = args?.waitTill;
            resourceInputs["webhooks"] = args?.webhooks;
            resourceInputs["workersInfos"] = args?.workersInfos;
            resourceInputs["albs"] = undefined /*out*/;
            resourceInputs["crn"] = undefined /*out*/;
            resourceInputs["ingressHostname"] = undefined /*out*/;
            resourceInputs["ingressSecret"] = undefined /*out*/;
            resourceInputs["privateServiceEndpointUrl"] = undefined /*out*/;
            resourceInputs["publicServiceEndpointUrl"] = undefined /*out*/;
            resourceInputs["resourceControllerUrl"] = undefined /*out*/;
            resourceInputs["resourceCrn"] = undefined /*out*/;
            resourceInputs["resourceGroupName"] = undefined /*out*/;
            resourceInputs["resourceName"] = undefined /*out*/;
            resourceInputs["resourceStatus"] = undefined /*out*/;
            resourceInputs["serverUrl"] = undefined /*out*/;
            resourceInputs["workerPools"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["ingressSecret"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ContainerCluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ContainerCluster resources.
 */
export interface ContainerClusterState {
    albs?: pulumi.Input<pulumi.Input<inputs.ContainerClusterAlb>[]>;
    /**
     * CRN of resource instance
     */
    crn?: pulumi.Input<string>;
    /**
     * The datacenter where this cluster will be deployed
     */
    datacenter?: pulumi.Input<string>;
    /**
     * The size of the default worker pool
     */
    defaultPoolSize?: pulumi.Input<number>;
    /**
     * disc encryption done, if set to true.
     */
    diskEncryption?: pulumi.Input<boolean>;
    /**
     * Entitlement option reduces additional OCP Licence cost in Openshift Clusters
     */
    entitlement?: pulumi.Input<string>;
    /**
     * Force the removal of a cluster and its persistent storage. Deleted data cannot be recovered
     */
    forceDeleteStorage?: pulumi.Input<boolean>;
    /**
     * Set true for gateway enabled clusters
     */
    gatewayEnabled?: pulumi.Input<boolean>;
    /**
     * Hardware type
     */
    hardware?: pulumi.Input<string>;
    /**
     * Set true to enable image security enforcement policies
     */
    imageSecurityEnforcement?: pulumi.Input<boolean>;
    ingressHostname?: pulumi.Input<string>;
    ingressSecret?: pulumi.Input<string>;
    /**
     * Enables KMS on a given cluster
     */
    kmsConfig?: pulumi.Input<inputs.ContainerClusterKmsConfig>;
    /**
     * Kubernetes version info
     */
    kubeVersion?: pulumi.Input<string>;
    /**
     * list of labels to the default worker pool
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Machine type
     */
    machineType?: pulumi.Input<string>;
    /**
     * The cluster name
     */
    name?: pulumi.Input<string>;
    /**
     * Boolean value set to true when subnet creation is not required.
     */
    noSubnet?: pulumi.Input<boolean>;
    /**
     * The operating system of the workers in the default worker pool.
     */
    operatingSystem?: pulumi.Input<string>;
    /**
     * Kubernetes patch version
     */
    patchVersion?: pulumi.Input<string>;
    /**
     * Custom subnet CIDR to provide private IP addresses for pods
     */
    podSubnet?: pulumi.Input<string>;
    privateServiceEndpoint?: pulumi.Input<boolean>;
    privateServiceEndpointUrl?: pulumi.Input<string>;
    /**
     * Private VLAN ID
     */
    privateVlanId?: pulumi.Input<string>;
    publicServiceEndpoint?: pulumi.Input<boolean>;
    publicServiceEndpointUrl?: pulumi.Input<string>;
    /**
     * Public VLAN ID
     */
    publicVlanId?: pulumi.Input<string>;
    /**
     * The cluster region
     *
     * @deprecated This field is deprecated
     */
    region?: pulumi.Input<string>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about this cluster
     */
    resourceControllerUrl?: pulumi.Input<string>;
    /**
     * The crn of the resource
     */
    resourceCrn?: pulumi.Input<string>;
    /**
     * ID of the resource group.
     */
    resourceGroupId?: pulumi.Input<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * The name of the resource
     */
    resourceName?: pulumi.Input<string>;
    /**
     * The status of the resource
     */
    resourceStatus?: pulumi.Input<string>;
    /**
     * Argument which helps to retry the patch version updates on worker nodes. Increment the value to retry the patch updates if the previous apply fails
     */
    retryPatchVersion?: pulumi.Input<number>;
    serverUrl?: pulumi.Input<string>;
    /**
     * Custom subnet CIDR to provide private IP addresses for services
     */
    serviceSubnet?: pulumi.Input<string>;
    /**
     * List of subnet IDs
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Tags for the resource
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * WorkerPool Taints
     */
    taints?: pulumi.Input<pulumi.Input<inputs.ContainerClusterTaint>[]>;
    /**
     * Updates all the woker nodes if sets to true
     */
    updateAllWorkers?: pulumi.Input<boolean>;
    /**
     * Wait for worker node to update during kube version update.
     */
    waitForWorkerUpdate?: pulumi.Input<boolean>;
    /**
     * wait_till can be configured for Master Ready, One worker Ready, Ingress Ready or Normal
     */
    waitTill?: pulumi.Input<string>;
    webhooks?: pulumi.Input<pulumi.Input<inputs.ContainerClusterWebhook>[]>;
    workerPools?: pulumi.Input<pulumi.Input<inputs.ContainerClusterWorkerPool>[]>;
    /**
     * The IDs of the worker node
     */
    workersInfos?: pulumi.Input<pulumi.Input<inputs.ContainerClusterWorkersInfo>[]>;
}

/**
 * The set of arguments for constructing a ContainerCluster resource.
 */
export interface ContainerClusterArgs {
    /**
     * The datacenter where this cluster will be deployed
     */
    datacenter: pulumi.Input<string>;
    /**
     * The size of the default worker pool
     */
    defaultPoolSize?: pulumi.Input<number>;
    /**
     * disc encryption done, if set to true.
     */
    diskEncryption?: pulumi.Input<boolean>;
    /**
     * Entitlement option reduces additional OCP Licence cost in Openshift Clusters
     */
    entitlement?: pulumi.Input<string>;
    /**
     * Force the removal of a cluster and its persistent storage. Deleted data cannot be recovered
     */
    forceDeleteStorage?: pulumi.Input<boolean>;
    /**
     * Set true for gateway enabled clusters
     */
    gatewayEnabled?: pulumi.Input<boolean>;
    /**
     * Hardware type
     */
    hardware: pulumi.Input<string>;
    /**
     * Set true to enable image security enforcement policies
     */
    imageSecurityEnforcement?: pulumi.Input<boolean>;
    /**
     * Enables KMS on a given cluster
     */
    kmsConfig?: pulumi.Input<inputs.ContainerClusterKmsConfig>;
    /**
     * Kubernetes version info
     */
    kubeVersion?: pulumi.Input<string>;
    /**
     * list of labels to the default worker pool
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Machine type
     */
    machineType?: pulumi.Input<string>;
    /**
     * The cluster name
     */
    name?: pulumi.Input<string>;
    /**
     * Boolean value set to true when subnet creation is not required.
     */
    noSubnet?: pulumi.Input<boolean>;
    /**
     * The operating system of the workers in the default worker pool.
     */
    operatingSystem?: pulumi.Input<string>;
    /**
     * Kubernetes patch version
     */
    patchVersion?: pulumi.Input<string>;
    /**
     * Custom subnet CIDR to provide private IP addresses for pods
     */
    podSubnet?: pulumi.Input<string>;
    privateServiceEndpoint?: pulumi.Input<boolean>;
    /**
     * Private VLAN ID
     */
    privateVlanId?: pulumi.Input<string>;
    publicServiceEndpoint?: pulumi.Input<boolean>;
    /**
     * Public VLAN ID
     */
    publicVlanId?: pulumi.Input<string>;
    /**
     * The cluster region
     *
     * @deprecated This field is deprecated
     */
    region?: pulumi.Input<string>;
    /**
     * ID of the resource group.
     */
    resourceGroupId?: pulumi.Input<string>;
    /**
     * Argument which helps to retry the patch version updates on worker nodes. Increment the value to retry the patch updates if the previous apply fails
     */
    retryPatchVersion?: pulumi.Input<number>;
    /**
     * Custom subnet CIDR to provide private IP addresses for services
     */
    serviceSubnet?: pulumi.Input<string>;
    /**
     * List of subnet IDs
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Tags for the resource
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * WorkerPool Taints
     */
    taints?: pulumi.Input<pulumi.Input<inputs.ContainerClusterTaint>[]>;
    /**
     * Updates all the woker nodes if sets to true
     */
    updateAllWorkers?: pulumi.Input<boolean>;
    /**
     * Wait for worker node to update during kube version update.
     */
    waitForWorkerUpdate?: pulumi.Input<boolean>;
    /**
     * wait_till can be configured for Master Ready, One worker Ready, Ingress Ready or Normal
     */
    waitTill?: pulumi.Input<string>;
    webhooks?: pulumi.Input<pulumi.Input<inputs.ContainerClusterWebhook>[]>;
    /**
     * The IDs of the worker node
     */
    workersInfos?: pulumi.Input<pulumi.Input<inputs.ContainerClusterWorkersInfo>[]>;
}
