// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class KmsKey extends pulumi.CustomResource {
    /**
     * Get an existing KmsKey resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KmsKeyState, opts?: pulumi.CustomResourceOptions): KmsKey {
        return new KmsKey(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ibmcloud:index/kmsKey:KmsKey';

    /**
     * Returns true if the given object is an instance of KmsKey.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KmsKey {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KmsKey.__pulumiType;
    }

    /**
     * Crn of the key
     */
    declare public /*out*/ readonly crn: pulumi.Output<string>;
    /**
     * description of the key
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Only for imported root key
     */
    declare public readonly encryptedNonce: pulumi.Output<string | undefined>;
    /**
     * public or private
     */
    declare public readonly endpointType: pulumi.Output<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    declare public readonly expirationDate: pulumi.Output<string | undefined>;
    /**
     * set to true to force delete the key
     */
    declare public readonly forceDelete: pulumi.Output<boolean | undefined>;
    /**
     * Key protect or hpcs instance CRN
     */
    declare public /*out*/ readonly instanceCrn: pulumi.Output<string>;
    /**
     * Key protect or hpcs instance GUID or CRN
     */
    declare public readonly instanceId: pulumi.Output<string>;
    /**
     * Only for imported root key
     */
    declare public readonly ivValue: pulumi.Output<string | undefined>;
    /**
     * Key ID
     */
    declare public /*out*/ readonly keyId: pulumi.Output<string>;
    /**
     * Key name
     */
    declare public readonly keyName: pulumi.Output<string>;
    /**
     * Key Ring for the Key
     */
    declare public readonly keyRingId: pulumi.Output<string | undefined>;
    declare public readonly payload: pulumi.Output<string>;
    /**
     * Registrations of the key across different services
     */
    declare public /*out*/ readonly registrations: pulumi.Output<outputs.KmsKeyRegistration[]>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
     */
    declare public /*out*/ readonly resourceControllerUrl: pulumi.Output<string>;
    /**
     * The crn of the resource
     */
    declare public /*out*/ readonly resourceCrn: pulumi.Output<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    declare public /*out*/ readonly resourceGroupName: pulumi.Output<string>;
    /**
     * The name of the resource
     */
    declare public /*out*/ readonly resourceName: pulumi.Output<string>;
    /**
     * The status of the resource
     */
    declare public /*out*/ readonly resourceStatus: pulumi.Output<string>;
    /**
     * Standard key type
     */
    declare public readonly standardKey: pulumi.Output<boolean | undefined>;
    /**
     * type of service hs-crypto or kms
     */
    declare public /*out*/ readonly type: pulumi.Output<string>;

    /**
     * Create a KmsKey resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KmsKeyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KmsKeyArgs | KmsKeyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KmsKeyState | undefined;
            resourceInputs["crn"] = state?.crn;
            resourceInputs["description"] = state?.description;
            resourceInputs["encryptedNonce"] = state?.encryptedNonce;
            resourceInputs["endpointType"] = state?.endpointType;
            resourceInputs["expirationDate"] = state?.expirationDate;
            resourceInputs["forceDelete"] = state?.forceDelete;
            resourceInputs["instanceCrn"] = state?.instanceCrn;
            resourceInputs["instanceId"] = state?.instanceId;
            resourceInputs["ivValue"] = state?.ivValue;
            resourceInputs["keyId"] = state?.keyId;
            resourceInputs["keyName"] = state?.keyName;
            resourceInputs["keyRingId"] = state?.keyRingId;
            resourceInputs["payload"] = state?.payload;
            resourceInputs["registrations"] = state?.registrations;
            resourceInputs["resourceControllerUrl"] = state?.resourceControllerUrl;
            resourceInputs["resourceCrn"] = state?.resourceCrn;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["resourceName"] = state?.resourceName;
            resourceInputs["resourceStatus"] = state?.resourceStatus;
            resourceInputs["standardKey"] = state?.standardKey;
            resourceInputs["type"] = state?.type;
        } else {
            const args = argsOrState as KmsKeyArgs | undefined;
            if (args?.instanceId === undefined && !opts.urn) {
                throw new Error("Missing required property 'instanceId'");
            }
            if (args?.keyName === undefined && !opts.urn) {
                throw new Error("Missing required property 'keyName'");
            }
            resourceInputs["description"] = args?.description;
            resourceInputs["encryptedNonce"] = args?.encryptedNonce;
            resourceInputs["endpointType"] = args?.endpointType;
            resourceInputs["expirationDate"] = args?.expirationDate;
            resourceInputs["forceDelete"] = args?.forceDelete;
            resourceInputs["instanceId"] = args?.instanceId;
            resourceInputs["ivValue"] = args?.ivValue;
            resourceInputs["keyName"] = args?.keyName;
            resourceInputs["keyRingId"] = args?.keyRingId;
            resourceInputs["payload"] = args?.payload ? pulumi.secret(args.payload) : undefined;
            resourceInputs["standardKey"] = args?.standardKey;
            resourceInputs["crn"] = undefined /*out*/;
            resourceInputs["instanceCrn"] = undefined /*out*/;
            resourceInputs["keyId"] = undefined /*out*/;
            resourceInputs["registrations"] = undefined /*out*/;
            resourceInputs["resourceControllerUrl"] = undefined /*out*/;
            resourceInputs["resourceCrn"] = undefined /*out*/;
            resourceInputs["resourceGroupName"] = undefined /*out*/;
            resourceInputs["resourceName"] = undefined /*out*/;
            resourceInputs["resourceStatus"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["payload"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(KmsKey.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KmsKey resources.
 */
export interface KmsKeyState {
    /**
     * Crn of the key
     */
    crn?: pulumi.Input<string>;
    /**
     * description of the key
     */
    description?: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    encryptedNonce?: pulumi.Input<string>;
    /**
     * public or private
     */
    endpointType?: pulumi.Input<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * set to true to force delete the key
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Key protect or hpcs instance CRN
     */
    instanceCrn?: pulumi.Input<string>;
    /**
     * Key protect or hpcs instance GUID or CRN
     */
    instanceId?: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    ivValue?: pulumi.Input<string>;
    /**
     * Key ID
     */
    keyId?: pulumi.Input<string>;
    /**
     * Key name
     */
    keyName?: pulumi.Input<string>;
    /**
     * Key Ring for the Key
     */
    keyRingId?: pulumi.Input<string>;
    payload?: pulumi.Input<string>;
    /**
     * Registrations of the key across different services
     */
    registrations?: pulumi.Input<pulumi.Input<inputs.KmsKeyRegistration>[]>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
     */
    resourceControllerUrl?: pulumi.Input<string>;
    /**
     * The crn of the resource
     */
    resourceCrn?: pulumi.Input<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * The name of the resource
     */
    resourceName?: pulumi.Input<string>;
    /**
     * The status of the resource
     */
    resourceStatus?: pulumi.Input<string>;
    /**
     * Standard key type
     */
    standardKey?: pulumi.Input<boolean>;
    /**
     * type of service hs-crypto or kms
     */
    type?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a KmsKey resource.
 */
export interface KmsKeyArgs {
    /**
     * description of the key
     */
    description?: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    encryptedNonce?: pulumi.Input<string>;
    /**
     * public or private
     */
    endpointType?: pulumi.Input<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * set to true to force delete the key
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Key protect or hpcs instance GUID or CRN
     */
    instanceId: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    ivValue?: pulumi.Input<string>;
    /**
     * Key name
     */
    keyName: pulumi.Input<string>;
    /**
     * Key Ring for the Key
     */
    keyRingId?: pulumi.Input<string>;
    payload?: pulumi.Input<string>;
    /**
     * Standard key type
     */
    standardKey?: pulumi.Input<boolean>;
}
