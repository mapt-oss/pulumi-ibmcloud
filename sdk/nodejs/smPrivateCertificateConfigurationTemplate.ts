// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class SmPrivateCertificateConfigurationTemplate extends pulumi.CustomResource {
    /**
     * Get an existing SmPrivateCertificateConfigurationTemplate resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SmPrivateCertificateConfigurationTemplateState, opts?: pulumi.CustomResourceOptions): SmPrivateCertificateConfigurationTemplate {
        return new SmPrivateCertificateConfigurationTemplate(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ibmcloud:index/smPrivateCertificateConfigurationTemplate:SmPrivateCertificateConfigurationTemplate';

    /**
     * Returns true if the given object is an instance of SmPrivateCertificateConfigurationTemplate.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SmPrivateCertificateConfigurationTemplate {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SmPrivateCertificateConfigurationTemplate.__pulumiType;
    }

    /**
     * Determines whether to allow clients to request a private certificate that matches any common name.
     */
    declare public readonly allowAnyName: pulumi.Output<boolean>;
    /**
     * Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowedDomains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
     */
    declare public readonly allowBareDomains: pulumi.Output<boolean>;
    /**
     * Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowedDomains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
     */
    declare public readonly allowGlobDomains: pulumi.Output<boolean>;
    /**
     * Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
     */
    declare public readonly allowIpSans: pulumi.Output<boolean>;
    /**
     * Determines whether to allow `localhost` to be included as one of the requested common names.
     */
    declare public readonly allowLocalhost: pulumi.Output<boolean>;
    /**
     * Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowedDomains` has a value of `example.com` and `allowSubdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allowAnyName` option.
     */
    declare public readonly allowSubdomains: pulumi.Output<boolean>;
    /**
     * Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allowGlobDomains`.
     */
    declare public readonly allowWildcardCertificates: pulumi.Output<boolean>;
    /**
     * The domains to define for the certificate template. This property is used along with the `allowBareDomains` and `allowSubdomains` options.
     */
    declare public readonly allowedDomains: pulumi.Output<string[]>;
    /**
     * Determines whether to allow the domains that are supplied in the `allowedDomains` field to contain access control list (ACL) templates.
     */
    declare public readonly allowedDomainsTemplate: pulumi.Output<boolean>;
    /**
     * The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `otherSans` input.
     */
    declare public readonly allowedOtherSans: pulumi.Output<string[]>;
    /**
     * Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
     */
    declare public readonly allowedSecretGroups: pulumi.Output<string>;
    /**
     * The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
     */
    declare public readonly allowedUriSans: pulumi.Output<string[]>;
    /**
     * Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
     */
    declare public readonly basicConstraintsValidForNonCa: pulumi.Output<boolean>;
    /**
     * The name of the intermediate certificate authority.
     */
    declare public readonly certificateAuthority: pulumi.Output<string>;
    /**
     * Determines whether private certificates are flagged for client use.
     */
    declare public readonly clientFlag: pulumi.Output<boolean>;
    /**
     * Determines whether private certificates are flagged for code signing use.
     */
    declare public readonly codeSigningFlag: pulumi.Output<boolean>;
    /**
     * The configuration type.
     */
    declare public /*out*/ readonly configType: pulumi.Output<string>;
    /**
     * The Country (C) values to define in the subject field of the resulting certificate.
     */
    declare public readonly countries: pulumi.Output<string[]>;
    /**
     * The date when a resource was created. The date format follows RFC 3339.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * The unique identifier that is associated with the entity that created the secret.
     */
    declare public /*out*/ readonly createdBy: pulumi.Output<string>;
    /**
     * Determines whether private certificates are flagged for email protection use.
     */
    declare public readonly emailProtectionFlag: pulumi.Output<boolean>;
    /**
     * public or private.
     */
    declare public readonly endpointType: pulumi.Output<string | undefined>;
    /**
     * Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
     */
    declare public readonly enforceHostnames: pulumi.Output<boolean>;
    /**
     * A list of extended key usage Object Identifiers (OIDs).
     */
    declare public readonly extKeyUsageOids: pulumi.Output<string[]>;
    /**
     * The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    declare public readonly extKeyUsages: pulumi.Output<string[]>;
    /**
     * The ID of the Secrets Manager instance.
     */
    declare public readonly instanceId: pulumi.Output<string>;
    /**
     * The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
     */
    declare public readonly keyBits: pulumi.Output<number>;
    /**
     * The type of private key to generate.
     */
    declare public readonly keyType: pulumi.Output<string>;
    /**
     * The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    declare public readonly keyUsages: pulumi.Output<string[]>;
    /**
     * The Locality (L) values to define in the subject field of the resulting certificate.
     */
    declare public readonly localities: pulumi.Output<string[]>;
    /**
     * The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
     */
    declare public readonly maxTtl: pulumi.Output<string | undefined>;
    /**
     * The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
     */
    declare public /*out*/ readonly maxTtlSeconds: pulumi.Output<number>;
    /**
     * A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The duration in seconds by which to backdate the `notBefore` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
     */
    declare public readonly notBeforeDuration: pulumi.Output<string | undefined>;
    /**
     * The duration in seconds by which to backdate the `notBefore` property of an issued private certificate.
     */
    declare public /*out*/ readonly notBeforeDurationSeconds: pulumi.Output<number>;
    /**
     * The Organization (O) values to define in the subject field of the resulting certificate.
     */
    declare public readonly organizations: pulumi.Output<string[]>;
    /**
     * The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
     */
    declare public readonly ous: pulumi.Output<string[]>;
    /**
     * A list of policy Object Identifiers (OIDs).
     */
    declare public readonly policyIdentifiers: pulumi.Output<string[]>;
    /**
     * The postal code values to define in the subject field of the resulting certificate.
     */
    declare public readonly postalCodes: pulumi.Output<string[]>;
    /**
     * The Province (ST) values to define in the subject field of the resulting certificate.
     */
    declare public readonly provinces: pulumi.Output<string[]>;
    /**
     * The region of the Secrets Manager instance.
     */
    declare public readonly region: pulumi.Output<string>;
    /**
     * Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `commonName` field optional, set the `requireCn` option to `false`.
     */
    declare public readonly requireCn: pulumi.Output<boolean>;
    /**
     * The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
     */
    declare public /*out*/ readonly secretType: pulumi.Output<string>;
    /**
     * Unused field.
     *
     * @deprecated This field is deprecated.
     */
    declare public readonly serialNumber: pulumi.Output<string>;
    /**
     * Determines whether private certificates are flagged for server use.
     */
    declare public readonly serverFlag: pulumi.Output<boolean>;
    /**
     * The street address values to define in the subject field of the resulting certificate.
     */
    declare public readonly streetAddresses: pulumi.Output<string[]>;
    /**
     * The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `maxTtl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
     */
    declare public readonly ttl: pulumi.Output<string | undefined>;
    /**
     * The requested Time To Live, after which the certificate will be expired.
     */
    declare public /*out*/ readonly ttlSeconds: pulumi.Output<number>;
    /**
     * The date when a resource was recently modified. The date format follows RFC 3339.
     */
    declare public /*out*/ readonly updatedAt: pulumi.Output<string>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `useCsrSans` property.
     */
    declare public readonly useCsrCommonName: pulumi.Output<boolean>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `useCsrCommonName` property.
     */
    declare public readonly useCsrSans: pulumi.Output<boolean>;

    /**
     * Create a SmPrivateCertificateConfigurationTemplate resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SmPrivateCertificateConfigurationTemplateArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SmPrivateCertificateConfigurationTemplateArgs | SmPrivateCertificateConfigurationTemplateState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SmPrivateCertificateConfigurationTemplateState | undefined;
            resourceInputs["allowAnyName"] = state?.allowAnyName;
            resourceInputs["allowBareDomains"] = state?.allowBareDomains;
            resourceInputs["allowGlobDomains"] = state?.allowGlobDomains;
            resourceInputs["allowIpSans"] = state?.allowIpSans;
            resourceInputs["allowLocalhost"] = state?.allowLocalhost;
            resourceInputs["allowSubdomains"] = state?.allowSubdomains;
            resourceInputs["allowWildcardCertificates"] = state?.allowWildcardCertificates;
            resourceInputs["allowedDomains"] = state?.allowedDomains;
            resourceInputs["allowedDomainsTemplate"] = state?.allowedDomainsTemplate;
            resourceInputs["allowedOtherSans"] = state?.allowedOtherSans;
            resourceInputs["allowedSecretGroups"] = state?.allowedSecretGroups;
            resourceInputs["allowedUriSans"] = state?.allowedUriSans;
            resourceInputs["basicConstraintsValidForNonCa"] = state?.basicConstraintsValidForNonCa;
            resourceInputs["certificateAuthority"] = state?.certificateAuthority;
            resourceInputs["clientFlag"] = state?.clientFlag;
            resourceInputs["codeSigningFlag"] = state?.codeSigningFlag;
            resourceInputs["configType"] = state?.configType;
            resourceInputs["countries"] = state?.countries;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["createdBy"] = state?.createdBy;
            resourceInputs["emailProtectionFlag"] = state?.emailProtectionFlag;
            resourceInputs["endpointType"] = state?.endpointType;
            resourceInputs["enforceHostnames"] = state?.enforceHostnames;
            resourceInputs["extKeyUsageOids"] = state?.extKeyUsageOids;
            resourceInputs["extKeyUsages"] = state?.extKeyUsages;
            resourceInputs["instanceId"] = state?.instanceId;
            resourceInputs["keyBits"] = state?.keyBits;
            resourceInputs["keyType"] = state?.keyType;
            resourceInputs["keyUsages"] = state?.keyUsages;
            resourceInputs["localities"] = state?.localities;
            resourceInputs["maxTtl"] = state?.maxTtl;
            resourceInputs["maxTtlSeconds"] = state?.maxTtlSeconds;
            resourceInputs["name"] = state?.name;
            resourceInputs["notBeforeDuration"] = state?.notBeforeDuration;
            resourceInputs["notBeforeDurationSeconds"] = state?.notBeforeDurationSeconds;
            resourceInputs["organizations"] = state?.organizations;
            resourceInputs["ous"] = state?.ous;
            resourceInputs["policyIdentifiers"] = state?.policyIdentifiers;
            resourceInputs["postalCodes"] = state?.postalCodes;
            resourceInputs["provinces"] = state?.provinces;
            resourceInputs["region"] = state?.region;
            resourceInputs["requireCn"] = state?.requireCn;
            resourceInputs["secretType"] = state?.secretType;
            resourceInputs["serialNumber"] = state?.serialNumber;
            resourceInputs["serverFlag"] = state?.serverFlag;
            resourceInputs["streetAddresses"] = state?.streetAddresses;
            resourceInputs["ttl"] = state?.ttl;
            resourceInputs["ttlSeconds"] = state?.ttlSeconds;
            resourceInputs["updatedAt"] = state?.updatedAt;
            resourceInputs["useCsrCommonName"] = state?.useCsrCommonName;
            resourceInputs["useCsrSans"] = state?.useCsrSans;
        } else {
            const args = argsOrState as SmPrivateCertificateConfigurationTemplateArgs | undefined;
            if (args?.certificateAuthority === undefined && !opts.urn) {
                throw new Error("Missing required property 'certificateAuthority'");
            }
            if (args?.instanceId === undefined && !opts.urn) {
                throw new Error("Missing required property 'instanceId'");
            }
            resourceInputs["allowAnyName"] = args?.allowAnyName;
            resourceInputs["allowBareDomains"] = args?.allowBareDomains;
            resourceInputs["allowGlobDomains"] = args?.allowGlobDomains;
            resourceInputs["allowIpSans"] = args?.allowIpSans;
            resourceInputs["allowLocalhost"] = args?.allowLocalhost;
            resourceInputs["allowSubdomains"] = args?.allowSubdomains;
            resourceInputs["allowWildcardCertificates"] = args?.allowWildcardCertificates;
            resourceInputs["allowedDomains"] = args?.allowedDomains;
            resourceInputs["allowedDomainsTemplate"] = args?.allowedDomainsTemplate;
            resourceInputs["allowedOtherSans"] = args?.allowedOtherSans;
            resourceInputs["allowedSecretGroups"] = args?.allowedSecretGroups;
            resourceInputs["allowedUriSans"] = args?.allowedUriSans;
            resourceInputs["basicConstraintsValidForNonCa"] = args?.basicConstraintsValidForNonCa;
            resourceInputs["certificateAuthority"] = args?.certificateAuthority;
            resourceInputs["clientFlag"] = args?.clientFlag;
            resourceInputs["codeSigningFlag"] = args?.codeSigningFlag;
            resourceInputs["countries"] = args?.countries;
            resourceInputs["emailProtectionFlag"] = args?.emailProtectionFlag;
            resourceInputs["endpointType"] = args?.endpointType;
            resourceInputs["enforceHostnames"] = args?.enforceHostnames;
            resourceInputs["extKeyUsageOids"] = args?.extKeyUsageOids;
            resourceInputs["extKeyUsages"] = args?.extKeyUsages;
            resourceInputs["instanceId"] = args?.instanceId;
            resourceInputs["keyBits"] = args?.keyBits;
            resourceInputs["keyType"] = args?.keyType;
            resourceInputs["keyUsages"] = args?.keyUsages;
            resourceInputs["localities"] = args?.localities;
            resourceInputs["maxTtl"] = args?.maxTtl;
            resourceInputs["name"] = args?.name;
            resourceInputs["notBeforeDuration"] = args?.notBeforeDuration;
            resourceInputs["organizations"] = args?.organizations;
            resourceInputs["ous"] = args?.ous;
            resourceInputs["policyIdentifiers"] = args?.policyIdentifiers;
            resourceInputs["postalCodes"] = args?.postalCodes;
            resourceInputs["provinces"] = args?.provinces;
            resourceInputs["region"] = args?.region;
            resourceInputs["requireCn"] = args?.requireCn;
            resourceInputs["serialNumber"] = args?.serialNumber;
            resourceInputs["serverFlag"] = args?.serverFlag;
            resourceInputs["streetAddresses"] = args?.streetAddresses;
            resourceInputs["ttl"] = args?.ttl;
            resourceInputs["useCsrCommonName"] = args?.useCsrCommonName;
            resourceInputs["useCsrSans"] = args?.useCsrSans;
            resourceInputs["configType"] = undefined /*out*/;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["createdBy"] = undefined /*out*/;
            resourceInputs["maxTtlSeconds"] = undefined /*out*/;
            resourceInputs["notBeforeDurationSeconds"] = undefined /*out*/;
            resourceInputs["secretType"] = undefined /*out*/;
            resourceInputs["ttlSeconds"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SmPrivateCertificateConfigurationTemplate.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering SmPrivateCertificateConfigurationTemplate resources.
 */
export interface SmPrivateCertificateConfigurationTemplateState {
    /**
     * Determines whether to allow clients to request a private certificate that matches any common name.
     */
    allowAnyName?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowedDomains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
     */
    allowBareDomains?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowedDomains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
     */
    allowGlobDomains?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
     */
    allowIpSans?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow `localhost` to be included as one of the requested common names.
     */
    allowLocalhost?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowedDomains` has a value of `example.com` and `allowSubdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allowAnyName` option.
     */
    allowSubdomains?: pulumi.Input<boolean>;
    /**
     * Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allowGlobDomains`.
     */
    allowWildcardCertificates?: pulumi.Input<boolean>;
    /**
     * The domains to define for the certificate template. This property is used along with the `allowBareDomains` and `allowSubdomains` options.
     */
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether to allow the domains that are supplied in the `allowedDomains` field to contain access control list (ACL) templates.
     */
    allowedDomainsTemplate?: pulumi.Input<boolean>;
    /**
     * The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `otherSans` input.
     */
    allowedOtherSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
     */
    allowedSecretGroups?: pulumi.Input<string>;
    /**
     * The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
     */
    allowedUriSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
     */
    basicConstraintsValidForNonCa?: pulumi.Input<boolean>;
    /**
     * The name of the intermediate certificate authority.
     */
    certificateAuthority?: pulumi.Input<string>;
    /**
     * Determines whether private certificates are flagged for client use.
     */
    clientFlag?: pulumi.Input<boolean>;
    /**
     * Determines whether private certificates are flagged for code signing use.
     */
    codeSigningFlag?: pulumi.Input<boolean>;
    /**
     * The configuration type.
     */
    configType?: pulumi.Input<string>;
    /**
     * The Country (C) values to define in the subject field of the resulting certificate.
     */
    countries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date when a resource was created. The date format follows RFC 3339.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * The unique identifier that is associated with the entity that created the secret.
     */
    createdBy?: pulumi.Input<string>;
    /**
     * Determines whether private certificates are flagged for email protection use.
     */
    emailProtectionFlag?: pulumi.Input<boolean>;
    /**
     * public or private.
     */
    endpointType?: pulumi.Input<string>;
    /**
     * Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
     */
    enforceHostnames?: pulumi.Input<boolean>;
    /**
     * A list of extended key usage Object Identifiers (OIDs).
     */
    extKeyUsageOids?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    extKeyUsages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Secrets Manager instance.
     */
    instanceId?: pulumi.Input<string>;
    /**
     * The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
     */
    keyBits?: pulumi.Input<number>;
    /**
     * The type of private key to generate.
     */
    keyType?: pulumi.Input<string>;
    /**
     * The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    keyUsages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Locality (L) values to define in the subject field of the resulting certificate.
     */
    localities?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
     */
    maxTtl?: pulumi.Input<string>;
    /**
     * The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
     */
    maxTtlSeconds?: pulumi.Input<number>;
    /**
     * A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
     */
    name?: pulumi.Input<string>;
    /**
     * The duration in seconds by which to backdate the `notBefore` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
     */
    notBeforeDuration?: pulumi.Input<string>;
    /**
     * The duration in seconds by which to backdate the `notBefore` property of an issued private certificate.
     */
    notBeforeDurationSeconds?: pulumi.Input<number>;
    /**
     * The Organization (O) values to define in the subject field of the resulting certificate.
     */
    organizations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
     */
    ous?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of policy Object Identifiers (OIDs).
     */
    policyIdentifiers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The postal code values to define in the subject field of the resulting certificate.
     */
    postalCodes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Province (ST) values to define in the subject field of the resulting certificate.
     */
    provinces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The region of the Secrets Manager instance.
     */
    region?: pulumi.Input<string>;
    /**
     * Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `commonName` field optional, set the `requireCn` option to `false`.
     */
    requireCn?: pulumi.Input<boolean>;
    /**
     * The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
     */
    secretType?: pulumi.Input<string>;
    /**
     * Unused field.
     *
     * @deprecated This field is deprecated.
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * Determines whether private certificates are flagged for server use.
     */
    serverFlag?: pulumi.Input<boolean>;
    /**
     * The street address values to define in the subject field of the resulting certificate.
     */
    streetAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `maxTtl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
     */
    ttl?: pulumi.Input<string>;
    /**
     * The requested Time To Live, after which the certificate will be expired.
     */
    ttlSeconds?: pulumi.Input<number>;
    /**
     * The date when a resource was recently modified. The date format follows RFC 3339.
     */
    updatedAt?: pulumi.Input<string>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `useCsrSans` property.
     */
    useCsrCommonName?: pulumi.Input<boolean>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `useCsrCommonName` property.
     */
    useCsrSans?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a SmPrivateCertificateConfigurationTemplate resource.
 */
export interface SmPrivateCertificateConfigurationTemplateArgs {
    /**
     * Determines whether to allow clients to request a private certificate that matches any common name.
     */
    allowAnyName?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowedDomains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
     */
    allowBareDomains?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowedDomains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
     */
    allowGlobDomains?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
     */
    allowIpSans?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow `localhost` to be included as one of the requested common names.
     */
    allowLocalhost?: pulumi.Input<boolean>;
    /**
     * Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowedDomains` has a value of `example.com` and `allowSubdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allowAnyName` option.
     */
    allowSubdomains?: pulumi.Input<boolean>;
    /**
     * Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allowGlobDomains`.
     */
    allowWildcardCertificates?: pulumi.Input<boolean>;
    /**
     * The domains to define for the certificate template. This property is used along with the `allowBareDomains` and `allowSubdomains` options.
     */
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether to allow the domains that are supplied in the `allowedDomains` field to contain access control list (ACL) templates.
     */
    allowedDomainsTemplate?: pulumi.Input<boolean>;
    /**
     * The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `otherSans` input.
     */
    allowedOtherSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
     */
    allowedSecretGroups?: pulumi.Input<string>;
    /**
     * The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
     */
    allowedUriSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
     */
    basicConstraintsValidForNonCa?: pulumi.Input<boolean>;
    /**
     * The name of the intermediate certificate authority.
     */
    certificateAuthority: pulumi.Input<string>;
    /**
     * Determines whether private certificates are flagged for client use.
     */
    clientFlag?: pulumi.Input<boolean>;
    /**
     * Determines whether private certificates are flagged for code signing use.
     */
    codeSigningFlag?: pulumi.Input<boolean>;
    /**
     * The Country (C) values to define in the subject field of the resulting certificate.
     */
    countries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether private certificates are flagged for email protection use.
     */
    emailProtectionFlag?: pulumi.Input<boolean>;
    /**
     * public or private.
     */
    endpointType?: pulumi.Input<string>;
    /**
     * Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
     */
    enforceHostnames?: pulumi.Input<boolean>;
    /**
     * A list of extended key usage Object Identifiers (OIDs).
     */
    extKeyUsageOids?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    extKeyUsages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Secrets Manager instance.
     */
    instanceId: pulumi.Input<string>;
    /**
     * The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
     */
    keyBits?: pulumi.Input<number>;
    /**
     * The type of private key to generate.
     */
    keyType?: pulumi.Input<string>;
    /**
     * The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
     */
    keyUsages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Locality (L) values to define in the subject field of the resulting certificate.
     */
    localities?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
     */
    maxTtl?: pulumi.Input<string>;
    /**
     * A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
     */
    name?: pulumi.Input<string>;
    /**
     * The duration in seconds by which to backdate the `notBefore` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
     */
    notBeforeDuration?: pulumi.Input<string>;
    /**
     * The Organization (O) values to define in the subject field of the resulting certificate.
     */
    organizations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
     */
    ous?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of policy Object Identifiers (OIDs).
     */
    policyIdentifiers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The postal code values to define in the subject field of the resulting certificate.
     */
    postalCodes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Province (ST) values to define in the subject field of the resulting certificate.
     */
    provinces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The region of the Secrets Manager instance.
     */
    region?: pulumi.Input<string>;
    /**
     * Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `commonName` field optional, set the `requireCn` option to `false`.
     */
    requireCn?: pulumi.Input<boolean>;
    /**
     * Unused field.
     *
     * @deprecated This field is deprecated.
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * Determines whether private certificates are flagged for server use.
     */
    serverFlag?: pulumi.Input<boolean>;
    /**
     * The street address values to define in the subject field of the resulting certificate.
     */
    streetAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `maxTtl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
     */
    ttl?: pulumi.Input<string>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `useCsrSans` property.
     */
    useCsrCommonName?: pulumi.Input<boolean>;
    /**
     * When used with the `privateCertConfigurationActionSignCsr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `useCsrCommonName` property.
     */
    useCsrSans?: pulumi.Input<boolean>;
}
