// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class KmsKeyWithPolicyOverrides extends pulumi.CustomResource {
    /**
     * Get an existing KmsKeyWithPolicyOverrides resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KmsKeyWithPolicyOverridesState, opts?: pulumi.CustomResourceOptions): KmsKeyWithPolicyOverrides {
        return new KmsKeyWithPolicyOverrides(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ibmcloud:index/kmsKeyWithPolicyOverrides:KmsKeyWithPolicyOverrides';

    /**
     * Returns true if the given object is an instance of KmsKeyWithPolicyOverrides.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KmsKeyWithPolicyOverrides {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KmsKeyWithPolicyOverrides.__pulumiType;
    }

    /**
     * Crn of the key
     */
    declare public /*out*/ readonly crn: pulumi.Output<string>;
    /**
     * description of the key
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Data associated with the dual authorization delete policy.
     */
    declare public readonly dualAuthDeletes: pulumi.Output<outputs.KmsKeyWithPolicyOverridesDualAuthDelete[]>;
    /**
     * Only for imported root key
     */
    declare public readonly encryptedNonce: pulumi.Output<string | undefined>;
    /**
     * Public or Private
     */
    declare public readonly endpointType: pulumi.Output<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    declare public readonly expirationDate: pulumi.Output<string | undefined>;
    /**
     * set to true to force delete the key
     */
    declare public readonly forceDelete: pulumi.Output<boolean | undefined>;
    /**
     * Key protect or HPCS instance CRN
     */
    declare public /*out*/ readonly instanceCrn: pulumi.Output<string>;
    /**
     * Key protect or HPCS instance GUID or CRN
     */
    declare public readonly instanceId: pulumi.Output<string>;
    /**
     * Only for imported root key
     */
    declare public readonly ivValue: pulumi.Output<string | undefined>;
    /**
     * Key ID
     */
    declare public /*out*/ readonly keyId: pulumi.Output<string>;
    /**
     * Key name
     */
    declare public readonly keyName: pulumi.Output<string>;
    /**
     * Key Ring for the Key
     */
    declare public readonly keyRingId: pulumi.Output<string | undefined>;
    declare public readonly payload: pulumi.Output<string>;
    /**
     * Registrations of the key across different services
     */
    declare public /*out*/ readonly registrations: pulumi.Output<outputs.KmsKeyWithPolicyOverridesRegistration[]>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
     */
    declare public /*out*/ readonly resourceControllerUrl: pulumi.Output<string>;
    /**
     * The crn of the resource
     */
    declare public /*out*/ readonly resourceCrn: pulumi.Output<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    declare public /*out*/ readonly resourceGroupName: pulumi.Output<string>;
    /**
     * The name of the resource
     */
    declare public /*out*/ readonly resourceName: pulumi.Output<string>;
    /**
     * The status of the resource
     */
    declare public /*out*/ readonly resourceStatus: pulumi.Output<string>;
    /**
     * Data associated with the key rotation policy
     */
    declare public readonly rotations: pulumi.Output<outputs.KmsKeyWithPolicyOverridesRotation[]>;
    /**
     * Standard key type
     */
    declare public readonly standardKey: pulumi.Output<boolean | undefined>;
    /**
     * Type of service hs-crypto or kms
     */
    declare public /*out*/ readonly type: pulumi.Output<string>;

    /**
     * Create a KmsKeyWithPolicyOverrides resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KmsKeyWithPolicyOverridesArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KmsKeyWithPolicyOverridesArgs | KmsKeyWithPolicyOverridesState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KmsKeyWithPolicyOverridesState | undefined;
            resourceInputs["crn"] = state?.crn;
            resourceInputs["description"] = state?.description;
            resourceInputs["dualAuthDeletes"] = state?.dualAuthDeletes;
            resourceInputs["encryptedNonce"] = state?.encryptedNonce;
            resourceInputs["endpointType"] = state?.endpointType;
            resourceInputs["expirationDate"] = state?.expirationDate;
            resourceInputs["forceDelete"] = state?.forceDelete;
            resourceInputs["instanceCrn"] = state?.instanceCrn;
            resourceInputs["instanceId"] = state?.instanceId;
            resourceInputs["ivValue"] = state?.ivValue;
            resourceInputs["keyId"] = state?.keyId;
            resourceInputs["keyName"] = state?.keyName;
            resourceInputs["keyRingId"] = state?.keyRingId;
            resourceInputs["payload"] = state?.payload;
            resourceInputs["registrations"] = state?.registrations;
            resourceInputs["resourceControllerUrl"] = state?.resourceControllerUrl;
            resourceInputs["resourceCrn"] = state?.resourceCrn;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["resourceName"] = state?.resourceName;
            resourceInputs["resourceStatus"] = state?.resourceStatus;
            resourceInputs["rotations"] = state?.rotations;
            resourceInputs["standardKey"] = state?.standardKey;
            resourceInputs["type"] = state?.type;
        } else {
            const args = argsOrState as KmsKeyWithPolicyOverridesArgs | undefined;
            if (args?.instanceId === undefined && !opts.urn) {
                throw new Error("Missing required property 'instanceId'");
            }
            if (args?.keyName === undefined && !opts.urn) {
                throw new Error("Missing required property 'keyName'");
            }
            resourceInputs["description"] = args?.description;
            resourceInputs["dualAuthDeletes"] = args?.dualAuthDeletes;
            resourceInputs["encryptedNonce"] = args?.encryptedNonce;
            resourceInputs["endpointType"] = args?.endpointType;
            resourceInputs["expirationDate"] = args?.expirationDate;
            resourceInputs["forceDelete"] = args?.forceDelete;
            resourceInputs["instanceId"] = args?.instanceId;
            resourceInputs["ivValue"] = args?.ivValue;
            resourceInputs["keyName"] = args?.keyName;
            resourceInputs["keyRingId"] = args?.keyRingId;
            resourceInputs["payload"] = args?.payload ? pulumi.secret(args.payload) : undefined;
            resourceInputs["rotations"] = args?.rotations;
            resourceInputs["standardKey"] = args?.standardKey;
            resourceInputs["crn"] = undefined /*out*/;
            resourceInputs["instanceCrn"] = undefined /*out*/;
            resourceInputs["keyId"] = undefined /*out*/;
            resourceInputs["registrations"] = undefined /*out*/;
            resourceInputs["resourceControllerUrl"] = undefined /*out*/;
            resourceInputs["resourceCrn"] = undefined /*out*/;
            resourceInputs["resourceGroupName"] = undefined /*out*/;
            resourceInputs["resourceName"] = undefined /*out*/;
            resourceInputs["resourceStatus"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["payload"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(KmsKeyWithPolicyOverrides.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KmsKeyWithPolicyOverrides resources.
 */
export interface KmsKeyWithPolicyOverridesState {
    /**
     * Crn of the key
     */
    crn?: pulumi.Input<string>;
    /**
     * description of the key
     */
    description?: pulumi.Input<string>;
    /**
     * Data associated with the dual authorization delete policy.
     */
    dualAuthDeletes?: pulumi.Input<pulumi.Input<inputs.KmsKeyWithPolicyOverridesDualAuthDelete>[]>;
    /**
     * Only for imported root key
     */
    encryptedNonce?: pulumi.Input<string>;
    /**
     * Public or Private
     */
    endpointType?: pulumi.Input<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * set to true to force delete the key
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Key protect or HPCS instance CRN
     */
    instanceCrn?: pulumi.Input<string>;
    /**
     * Key protect or HPCS instance GUID or CRN
     */
    instanceId?: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    ivValue?: pulumi.Input<string>;
    /**
     * Key ID
     */
    keyId?: pulumi.Input<string>;
    /**
     * Key name
     */
    keyName?: pulumi.Input<string>;
    /**
     * Key Ring for the Key
     */
    keyRingId?: pulumi.Input<string>;
    payload?: pulumi.Input<string>;
    /**
     * Registrations of the key across different services
     */
    registrations?: pulumi.Input<pulumi.Input<inputs.KmsKeyWithPolicyOverridesRegistration>[]>;
    /**
     * The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
     */
    resourceControllerUrl?: pulumi.Input<string>;
    /**
     * The crn of the resource
     */
    resourceCrn?: pulumi.Input<string>;
    /**
     * The resource group name in which resource is provisioned
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * The name of the resource
     */
    resourceName?: pulumi.Input<string>;
    /**
     * The status of the resource
     */
    resourceStatus?: pulumi.Input<string>;
    /**
     * Data associated with the key rotation policy
     */
    rotations?: pulumi.Input<pulumi.Input<inputs.KmsKeyWithPolicyOverridesRotation>[]>;
    /**
     * Standard key type
     */
    standardKey?: pulumi.Input<boolean>;
    /**
     * Type of service hs-crypto or kms
     */
    type?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a KmsKeyWithPolicyOverrides resource.
 */
export interface KmsKeyWithPolicyOverridesArgs {
    /**
     * description of the key
     */
    description?: pulumi.Input<string>;
    /**
     * Data associated with the dual authorization delete policy.
     */
    dualAuthDeletes?: pulumi.Input<pulumi.Input<inputs.KmsKeyWithPolicyOverridesDualAuthDelete>[]>;
    /**
     * Only for imported root key
     */
    encryptedNonce?: pulumi.Input<string>;
    /**
     * Public or Private
     */
    endpointType?: pulumi.Input<string>;
    /**
     * The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * set to true to force delete the key
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Key protect or HPCS instance GUID or CRN
     */
    instanceId: pulumi.Input<string>;
    /**
     * Only for imported root key
     */
    ivValue?: pulumi.Input<string>;
    /**
     * Key name
     */
    keyName: pulumi.Input<string>;
    /**
     * Key Ring for the Key
     */
    keyRingId?: pulumi.Input<string>;
    payload?: pulumi.Input<string>;
    /**
     * Data associated with the key rotation policy
     */
    rotations?: pulumi.Input<pulumi.Input<inputs.KmsKeyWithPolicyOverridesRotation>[]>;
    /**
     * Standard key type
     */
    standardKey?: pulumi.Input<boolean>;
}
