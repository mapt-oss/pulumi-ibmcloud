// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ibmcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/mapt-oss/pulumi-ibmcloud/sdk/go/ibmcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type LogsRuleGroup struct {
	pulumi.CustomResourceState

	// A description for the rule group, should express what is the rule group purpose.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether or not the rule is enabled.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// public or private.
	EndpointType pulumi.StringPtrOutput `pulumi:"endpointType"`
	// The ID of the logs instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// The name of the rule group.
	Name pulumi.StringOutput `pulumi:"name"`
	// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
	Order pulumi.IntPtrOutput `pulumi:"order"`
	// The region of the logs instance.
	Region pulumi.StringOutput `pulumi:"region"`
	// Rule Group Id.
	RuleGroupId pulumi.StringOutput `pulumi:"ruleGroupId"`
	// // Optional rule matchers which if matched will make the rule go through the rule group.
	RuleMatchers LogsRuleGroupRuleMatcherArrayOutput `pulumi:"ruleMatchers"`
	// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
	RuleSubgroups LogsRuleGroupRuleSubgroupArrayOutput `pulumi:"ruleSubgroups"`
}

// NewLogsRuleGroup registers a new resource with the given unique name, arguments, and options.
func NewLogsRuleGroup(ctx *pulumi.Context,
	name string, args *LogsRuleGroupArgs, opts ...pulumi.ResourceOption) (*LogsRuleGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.RuleSubgroups == nil {
		return nil, errors.New("invalid value for required argument 'RuleSubgroups'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogsRuleGroup
	err := ctx.RegisterResource("ibmcloud:index/logsRuleGroup:LogsRuleGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogsRuleGroup gets an existing LogsRuleGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogsRuleGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogsRuleGroupState, opts ...pulumi.ResourceOption) (*LogsRuleGroup, error) {
	var resource LogsRuleGroup
	err := ctx.ReadResource("ibmcloud:index/logsRuleGroup:LogsRuleGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogsRuleGroup resources.
type logsRuleGroupState struct {
	// A description for the rule group, should express what is the rule group purpose.
	Description *string `pulumi:"description"`
	// Whether or not the rule is enabled.
	Enabled *bool `pulumi:"enabled"`
	// public or private.
	EndpointType *string `pulumi:"endpointType"`
	// The ID of the logs instance.
	InstanceId *string `pulumi:"instanceId"`
	// The name of the rule group.
	Name *string `pulumi:"name"`
	// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
	Order *int `pulumi:"order"`
	// The region of the logs instance.
	Region *string `pulumi:"region"`
	// Rule Group Id.
	RuleGroupId *string `pulumi:"ruleGroupId"`
	// // Optional rule matchers which if matched will make the rule go through the rule group.
	RuleMatchers []LogsRuleGroupRuleMatcher `pulumi:"ruleMatchers"`
	// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
	RuleSubgroups []LogsRuleGroupRuleSubgroup `pulumi:"ruleSubgroups"`
}

type LogsRuleGroupState struct {
	// A description for the rule group, should express what is the rule group purpose.
	Description pulumi.StringPtrInput
	// Whether or not the rule is enabled.
	Enabled pulumi.BoolPtrInput
	// public or private.
	EndpointType pulumi.StringPtrInput
	// The ID of the logs instance.
	InstanceId pulumi.StringPtrInput
	// The name of the rule group.
	Name pulumi.StringPtrInput
	// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
	Order pulumi.IntPtrInput
	// The region of the logs instance.
	Region pulumi.StringPtrInput
	// Rule Group Id.
	RuleGroupId pulumi.StringPtrInput
	// // Optional rule matchers which if matched will make the rule go through the rule group.
	RuleMatchers LogsRuleGroupRuleMatcherArrayInput
	// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
	RuleSubgroups LogsRuleGroupRuleSubgroupArrayInput
}

func (LogsRuleGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*logsRuleGroupState)(nil)).Elem()
}

type logsRuleGroupArgs struct {
	// A description for the rule group, should express what is the rule group purpose.
	Description *string `pulumi:"description"`
	// Whether or not the rule is enabled.
	Enabled *bool `pulumi:"enabled"`
	// public or private.
	EndpointType *string `pulumi:"endpointType"`
	// The ID of the logs instance.
	InstanceId string `pulumi:"instanceId"`
	// The name of the rule group.
	Name *string `pulumi:"name"`
	// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
	Order *int `pulumi:"order"`
	// The region of the logs instance.
	Region *string `pulumi:"region"`
	// // Optional rule matchers which if matched will make the rule go through the rule group.
	RuleMatchers []LogsRuleGroupRuleMatcher `pulumi:"ruleMatchers"`
	// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
	RuleSubgroups []LogsRuleGroupRuleSubgroup `pulumi:"ruleSubgroups"`
}

// The set of arguments for constructing a LogsRuleGroup resource.
type LogsRuleGroupArgs struct {
	// A description for the rule group, should express what is the rule group purpose.
	Description pulumi.StringPtrInput
	// Whether or not the rule is enabled.
	Enabled pulumi.BoolPtrInput
	// public or private.
	EndpointType pulumi.StringPtrInput
	// The ID of the logs instance.
	InstanceId pulumi.StringInput
	// The name of the rule group.
	Name pulumi.StringPtrInput
	// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
	Order pulumi.IntPtrInput
	// The region of the logs instance.
	Region pulumi.StringPtrInput
	// // Optional rule matchers which if matched will make the rule go through the rule group.
	RuleMatchers LogsRuleGroupRuleMatcherArrayInput
	// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
	RuleSubgroups LogsRuleGroupRuleSubgroupArrayInput
}

func (LogsRuleGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logsRuleGroupArgs)(nil)).Elem()
}

type LogsRuleGroupInput interface {
	pulumi.Input

	ToLogsRuleGroupOutput() LogsRuleGroupOutput
	ToLogsRuleGroupOutputWithContext(ctx context.Context) LogsRuleGroupOutput
}

func (*LogsRuleGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsRuleGroup)(nil)).Elem()
}

func (i *LogsRuleGroup) ToLogsRuleGroupOutput() LogsRuleGroupOutput {
	return i.ToLogsRuleGroupOutputWithContext(context.Background())
}

func (i *LogsRuleGroup) ToLogsRuleGroupOutputWithContext(ctx context.Context) LogsRuleGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsRuleGroupOutput)
}

// LogsRuleGroupArrayInput is an input type that accepts LogsRuleGroupArray and LogsRuleGroupArrayOutput values.
// You can construct a concrete instance of `LogsRuleGroupArrayInput` via:
//
//	LogsRuleGroupArray{ LogsRuleGroupArgs{...} }
type LogsRuleGroupArrayInput interface {
	pulumi.Input

	ToLogsRuleGroupArrayOutput() LogsRuleGroupArrayOutput
	ToLogsRuleGroupArrayOutputWithContext(context.Context) LogsRuleGroupArrayOutput
}

type LogsRuleGroupArray []LogsRuleGroupInput

func (LogsRuleGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsRuleGroup)(nil)).Elem()
}

func (i LogsRuleGroupArray) ToLogsRuleGroupArrayOutput() LogsRuleGroupArrayOutput {
	return i.ToLogsRuleGroupArrayOutputWithContext(context.Background())
}

func (i LogsRuleGroupArray) ToLogsRuleGroupArrayOutputWithContext(ctx context.Context) LogsRuleGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsRuleGroupArrayOutput)
}

// LogsRuleGroupMapInput is an input type that accepts LogsRuleGroupMap and LogsRuleGroupMapOutput values.
// You can construct a concrete instance of `LogsRuleGroupMapInput` via:
//
//	LogsRuleGroupMap{ "key": LogsRuleGroupArgs{...} }
type LogsRuleGroupMapInput interface {
	pulumi.Input

	ToLogsRuleGroupMapOutput() LogsRuleGroupMapOutput
	ToLogsRuleGroupMapOutputWithContext(context.Context) LogsRuleGroupMapOutput
}

type LogsRuleGroupMap map[string]LogsRuleGroupInput

func (LogsRuleGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsRuleGroup)(nil)).Elem()
}

func (i LogsRuleGroupMap) ToLogsRuleGroupMapOutput() LogsRuleGroupMapOutput {
	return i.ToLogsRuleGroupMapOutputWithContext(context.Background())
}

func (i LogsRuleGroupMap) ToLogsRuleGroupMapOutputWithContext(ctx context.Context) LogsRuleGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsRuleGroupMapOutput)
}

type LogsRuleGroupOutput struct{ *pulumi.OutputState }

func (LogsRuleGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsRuleGroup)(nil)).Elem()
}

func (o LogsRuleGroupOutput) ToLogsRuleGroupOutput() LogsRuleGroupOutput {
	return o
}

func (o LogsRuleGroupOutput) ToLogsRuleGroupOutputWithContext(ctx context.Context) LogsRuleGroupOutput {
	return o
}

// A description for the rule group, should express what is the rule group purpose.
func (o LogsRuleGroupOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether or not the rule is enabled.
func (o LogsRuleGroupOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// public or private.
func (o LogsRuleGroupOutput) EndpointType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringPtrOutput { return v.EndpointType }).(pulumi.StringPtrOutput)
}

// The ID of the logs instance.
func (o LogsRuleGroupOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// The name of the rule group.
func (o LogsRuleGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// // The order in which the rule group will be evaluated. The lower the order, the more priority the group will have. Not providing the order will by default create a group with the last order.
func (o LogsRuleGroupOutput) Order() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.IntPtrOutput { return v.Order }).(pulumi.IntPtrOutput)
}

// The region of the logs instance.
func (o LogsRuleGroupOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Rule Group Id.
func (o LogsRuleGroupOutput) RuleGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsRuleGroup) pulumi.StringOutput { return v.RuleGroupId }).(pulumi.StringOutput)
}

// // Optional rule matchers which if matched will make the rule go through the rule group.
func (o LogsRuleGroupOutput) RuleMatchers() LogsRuleGroupRuleMatcherArrayOutput {
	return o.ApplyT(func(v *LogsRuleGroup) LogsRuleGroupRuleMatcherArrayOutput { return v.RuleMatchers }).(LogsRuleGroupRuleMatcherArrayOutput)
}

// Rule subgroups. Will try to execute the first rule subgroup, and if not matched will try to match the next one in order.
func (o LogsRuleGroupOutput) RuleSubgroups() LogsRuleGroupRuleSubgroupArrayOutput {
	return o.ApplyT(func(v *LogsRuleGroup) LogsRuleGroupRuleSubgroupArrayOutput { return v.RuleSubgroups }).(LogsRuleGroupRuleSubgroupArrayOutput)
}

type LogsRuleGroupArrayOutput struct{ *pulumi.OutputState }

func (LogsRuleGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsRuleGroup)(nil)).Elem()
}

func (o LogsRuleGroupArrayOutput) ToLogsRuleGroupArrayOutput() LogsRuleGroupArrayOutput {
	return o
}

func (o LogsRuleGroupArrayOutput) ToLogsRuleGroupArrayOutputWithContext(ctx context.Context) LogsRuleGroupArrayOutput {
	return o
}

func (o LogsRuleGroupArrayOutput) Index(i pulumi.IntInput) LogsRuleGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogsRuleGroup {
		return vs[0].([]*LogsRuleGroup)[vs[1].(int)]
	}).(LogsRuleGroupOutput)
}

type LogsRuleGroupMapOutput struct{ *pulumi.OutputState }

func (LogsRuleGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsRuleGroup)(nil)).Elem()
}

func (o LogsRuleGroupMapOutput) ToLogsRuleGroupMapOutput() LogsRuleGroupMapOutput {
	return o
}

func (o LogsRuleGroupMapOutput) ToLogsRuleGroupMapOutputWithContext(ctx context.Context) LogsRuleGroupMapOutput {
	return o
}

func (o LogsRuleGroupMapOutput) MapIndex(k pulumi.StringInput) LogsRuleGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogsRuleGroup {
		return vs[0].(map[string]*LogsRuleGroup)[vs[1].(string)]
	}).(LogsRuleGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogsRuleGroupInput)(nil)).Elem(), &LogsRuleGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsRuleGroupArrayInput)(nil)).Elem(), LogsRuleGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsRuleGroupMapInput)(nil)).Elem(), LogsRuleGroupMap{})
	pulumi.RegisterOutputType(LogsRuleGroupOutput{})
	pulumi.RegisterOutputType(LogsRuleGroupArrayOutput{})
	pulumi.RegisterOutputType(LogsRuleGroupMapOutput{})
}
