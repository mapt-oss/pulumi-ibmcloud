// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ibmcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/mapt-oss/pulumi-ibmcloud/sdk/go/ibmcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type KmsKeyWithPolicyOverrides struct {
	pulumi.CustomResourceState

	// Crn of the key
	Crn pulumi.StringOutput `pulumi:"crn"`
	// description of the key
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Data associated with the dual authorization delete policy.
	DualAuthDeletes KmsKeyWithPolicyOverridesDualAuthDeleteArrayOutput `pulumi:"dualAuthDeletes"`
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrOutput `pulumi:"encryptedNonce"`
	// Public or Private
	EndpointType pulumi.StringOutput `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrOutput `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrOutput `pulumi:"forceDelete"`
	// Key protect or HPCS instance CRN
	InstanceCrn pulumi.StringOutput `pulumi:"instanceCrn"`
	// Key protect or HPCS instance GUID or CRN
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// Only for imported root key
	IvValue pulumi.StringPtrOutput `pulumi:"ivValue"`
	// Key ID
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Key name
	KeyName pulumi.StringOutput `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrOutput `pulumi:"keyRingId"`
	Payload   pulumi.StringOutput    `pulumi:"payload"`
	// Registrations of the key across different services
	Registrations KmsKeyWithPolicyOverridesRegistrationArrayOutput `pulumi:"registrations"`
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl pulumi.StringOutput `pulumi:"resourceControllerUrl"`
	// The crn of the resource
	ResourceCrn pulumi.StringOutput `pulumi:"resourceCrn"`
	// The resource group name in which resource is provisioned
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// The name of the resource
	ResourceName pulumi.StringOutput `pulumi:"resourceName"`
	// The status of the resource
	ResourceStatus pulumi.StringOutput `pulumi:"resourceStatus"`
	// Data associated with the key rotation policy
	Rotations KmsKeyWithPolicyOverridesRotationArrayOutput `pulumi:"rotations"`
	// Standard key type
	StandardKey pulumi.BoolPtrOutput `pulumi:"standardKey"`
	// Type of service hs-crypto or kms
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewKmsKeyWithPolicyOverrides registers a new resource with the given unique name, arguments, and options.
func NewKmsKeyWithPolicyOverrides(ctx *pulumi.Context,
	name string, args *KmsKeyWithPolicyOverridesArgs, opts ...pulumi.ResourceOption) (*KmsKeyWithPolicyOverrides, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.KeyName == nil {
		return nil, errors.New("invalid value for required argument 'KeyName'")
	}
	if args.Payload != nil {
		args.Payload = pulumi.ToSecret(args.Payload).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"payload",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KmsKeyWithPolicyOverrides
	err := ctx.RegisterResource("ibmcloud:index/kmsKeyWithPolicyOverrides:KmsKeyWithPolicyOverrides", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsKeyWithPolicyOverrides gets an existing KmsKeyWithPolicyOverrides resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsKeyWithPolicyOverrides(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsKeyWithPolicyOverridesState, opts ...pulumi.ResourceOption) (*KmsKeyWithPolicyOverrides, error) {
	var resource KmsKeyWithPolicyOverrides
	err := ctx.ReadResource("ibmcloud:index/kmsKeyWithPolicyOverrides:KmsKeyWithPolicyOverrides", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsKeyWithPolicyOverrides resources.
type kmsKeyWithPolicyOverridesState struct {
	// Crn of the key
	Crn *string `pulumi:"crn"`
	// description of the key
	Description *string `pulumi:"description"`
	// Data associated with the dual authorization delete policy.
	DualAuthDeletes []KmsKeyWithPolicyOverridesDualAuthDelete `pulumi:"dualAuthDeletes"`
	// Only for imported root key
	EncryptedNonce *string `pulumi:"encryptedNonce"`
	// Public or Private
	EndpointType *string `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate *string `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete *bool `pulumi:"forceDelete"`
	// Key protect or HPCS instance CRN
	InstanceCrn *string `pulumi:"instanceCrn"`
	// Key protect or HPCS instance GUID or CRN
	InstanceId *string `pulumi:"instanceId"`
	// Only for imported root key
	IvValue *string `pulumi:"ivValue"`
	// Key ID
	KeyId *string `pulumi:"keyId"`
	// Key name
	KeyName *string `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId *string `pulumi:"keyRingId"`
	Payload   *string `pulumi:"payload"`
	// Registrations of the key across different services
	Registrations []KmsKeyWithPolicyOverridesRegistration `pulumi:"registrations"`
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl *string `pulumi:"resourceControllerUrl"`
	// The crn of the resource
	ResourceCrn *string `pulumi:"resourceCrn"`
	// The resource group name in which resource is provisioned
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// The name of the resource
	ResourceName *string `pulumi:"resourceName"`
	// The status of the resource
	ResourceStatus *string `pulumi:"resourceStatus"`
	// Data associated with the key rotation policy
	Rotations []KmsKeyWithPolicyOverridesRotation `pulumi:"rotations"`
	// Standard key type
	StandardKey *bool `pulumi:"standardKey"`
	// Type of service hs-crypto or kms
	Type *string `pulumi:"type"`
}

type KmsKeyWithPolicyOverridesState struct {
	// Crn of the key
	Crn pulumi.StringPtrInput
	// description of the key
	Description pulumi.StringPtrInput
	// Data associated with the dual authorization delete policy.
	DualAuthDeletes KmsKeyWithPolicyOverridesDualAuthDeleteArrayInput
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrInput
	// Public or Private
	EndpointType pulumi.StringPtrInput
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrInput
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrInput
	// Key protect or HPCS instance CRN
	InstanceCrn pulumi.StringPtrInput
	// Key protect or HPCS instance GUID or CRN
	InstanceId pulumi.StringPtrInput
	// Only for imported root key
	IvValue pulumi.StringPtrInput
	// Key ID
	KeyId pulumi.StringPtrInput
	// Key name
	KeyName pulumi.StringPtrInput
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrInput
	Payload   pulumi.StringPtrInput
	// Registrations of the key across different services
	Registrations KmsKeyWithPolicyOverridesRegistrationArrayInput
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl pulumi.StringPtrInput
	// The crn of the resource
	ResourceCrn pulumi.StringPtrInput
	// The resource group name in which resource is provisioned
	ResourceGroupName pulumi.StringPtrInput
	// The name of the resource
	ResourceName pulumi.StringPtrInput
	// The status of the resource
	ResourceStatus pulumi.StringPtrInput
	// Data associated with the key rotation policy
	Rotations KmsKeyWithPolicyOverridesRotationArrayInput
	// Standard key type
	StandardKey pulumi.BoolPtrInput
	// Type of service hs-crypto or kms
	Type pulumi.StringPtrInput
}

func (KmsKeyWithPolicyOverridesState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyWithPolicyOverridesState)(nil)).Elem()
}

type kmsKeyWithPolicyOverridesArgs struct {
	// description of the key
	Description *string `pulumi:"description"`
	// Data associated with the dual authorization delete policy.
	DualAuthDeletes []KmsKeyWithPolicyOverridesDualAuthDelete `pulumi:"dualAuthDeletes"`
	// Only for imported root key
	EncryptedNonce *string `pulumi:"encryptedNonce"`
	// Public or Private
	EndpointType *string `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate *string `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete *bool `pulumi:"forceDelete"`
	// Key protect or HPCS instance GUID or CRN
	InstanceId string `pulumi:"instanceId"`
	// Only for imported root key
	IvValue *string `pulumi:"ivValue"`
	// Key name
	KeyName string `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId *string `pulumi:"keyRingId"`
	Payload   *string `pulumi:"payload"`
	// Data associated with the key rotation policy
	Rotations []KmsKeyWithPolicyOverridesRotation `pulumi:"rotations"`
	// Standard key type
	StandardKey *bool `pulumi:"standardKey"`
}

// The set of arguments for constructing a KmsKeyWithPolicyOverrides resource.
type KmsKeyWithPolicyOverridesArgs struct {
	// description of the key
	Description pulumi.StringPtrInput
	// Data associated with the dual authorization delete policy.
	DualAuthDeletes KmsKeyWithPolicyOverridesDualAuthDeleteArrayInput
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrInput
	// Public or Private
	EndpointType pulumi.StringPtrInput
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrInput
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrInput
	// Key protect or HPCS instance GUID or CRN
	InstanceId pulumi.StringInput
	// Only for imported root key
	IvValue pulumi.StringPtrInput
	// Key name
	KeyName pulumi.StringInput
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrInput
	Payload   pulumi.StringPtrInput
	// Data associated with the key rotation policy
	Rotations KmsKeyWithPolicyOverridesRotationArrayInput
	// Standard key type
	StandardKey pulumi.BoolPtrInput
}

func (KmsKeyWithPolicyOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyWithPolicyOverridesArgs)(nil)).Elem()
}

type KmsKeyWithPolicyOverridesInput interface {
	pulumi.Input

	ToKmsKeyWithPolicyOverridesOutput() KmsKeyWithPolicyOverridesOutput
	ToKmsKeyWithPolicyOverridesOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesOutput
}

func (*KmsKeyWithPolicyOverrides) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (i *KmsKeyWithPolicyOverrides) ToKmsKeyWithPolicyOverridesOutput() KmsKeyWithPolicyOverridesOutput {
	return i.ToKmsKeyWithPolicyOverridesOutputWithContext(context.Background())
}

func (i *KmsKeyWithPolicyOverrides) ToKmsKeyWithPolicyOverridesOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyWithPolicyOverridesOutput)
}

// KmsKeyWithPolicyOverridesArrayInput is an input type that accepts KmsKeyWithPolicyOverridesArray and KmsKeyWithPolicyOverridesArrayOutput values.
// You can construct a concrete instance of `KmsKeyWithPolicyOverridesArrayInput` via:
//
//	KmsKeyWithPolicyOverridesArray{ KmsKeyWithPolicyOverridesArgs{...} }
type KmsKeyWithPolicyOverridesArrayInput interface {
	pulumi.Input

	ToKmsKeyWithPolicyOverridesArrayOutput() KmsKeyWithPolicyOverridesArrayOutput
	ToKmsKeyWithPolicyOverridesArrayOutputWithContext(context.Context) KmsKeyWithPolicyOverridesArrayOutput
}

type KmsKeyWithPolicyOverridesArray []KmsKeyWithPolicyOverridesInput

func (KmsKeyWithPolicyOverridesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (i KmsKeyWithPolicyOverridesArray) ToKmsKeyWithPolicyOverridesArrayOutput() KmsKeyWithPolicyOverridesArrayOutput {
	return i.ToKmsKeyWithPolicyOverridesArrayOutputWithContext(context.Background())
}

func (i KmsKeyWithPolicyOverridesArray) ToKmsKeyWithPolicyOverridesArrayOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyWithPolicyOverridesArrayOutput)
}

// KmsKeyWithPolicyOverridesMapInput is an input type that accepts KmsKeyWithPolicyOverridesMap and KmsKeyWithPolicyOverridesMapOutput values.
// You can construct a concrete instance of `KmsKeyWithPolicyOverridesMapInput` via:
//
//	KmsKeyWithPolicyOverridesMap{ "key": KmsKeyWithPolicyOverridesArgs{...} }
type KmsKeyWithPolicyOverridesMapInput interface {
	pulumi.Input

	ToKmsKeyWithPolicyOverridesMapOutput() KmsKeyWithPolicyOverridesMapOutput
	ToKmsKeyWithPolicyOverridesMapOutputWithContext(context.Context) KmsKeyWithPolicyOverridesMapOutput
}

type KmsKeyWithPolicyOverridesMap map[string]KmsKeyWithPolicyOverridesInput

func (KmsKeyWithPolicyOverridesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (i KmsKeyWithPolicyOverridesMap) ToKmsKeyWithPolicyOverridesMapOutput() KmsKeyWithPolicyOverridesMapOutput {
	return i.ToKmsKeyWithPolicyOverridesMapOutputWithContext(context.Background())
}

func (i KmsKeyWithPolicyOverridesMap) ToKmsKeyWithPolicyOverridesMapOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyWithPolicyOverridesMapOutput)
}

type KmsKeyWithPolicyOverridesOutput struct{ *pulumi.OutputState }

func (KmsKeyWithPolicyOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (o KmsKeyWithPolicyOverridesOutput) ToKmsKeyWithPolicyOverridesOutput() KmsKeyWithPolicyOverridesOutput {
	return o
}

func (o KmsKeyWithPolicyOverridesOutput) ToKmsKeyWithPolicyOverridesOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesOutput {
	return o
}

// Crn of the key
func (o KmsKeyWithPolicyOverridesOutput) Crn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.Crn }).(pulumi.StringOutput)
}

// description of the key
func (o KmsKeyWithPolicyOverridesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Data associated with the dual authorization delete policy.
func (o KmsKeyWithPolicyOverridesOutput) DualAuthDeletes() KmsKeyWithPolicyOverridesDualAuthDeleteArrayOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) KmsKeyWithPolicyOverridesDualAuthDeleteArrayOutput {
		return v.DualAuthDeletes
	}).(KmsKeyWithPolicyOverridesDualAuthDeleteArrayOutput)
}

// Only for imported root key
func (o KmsKeyWithPolicyOverridesOutput) EncryptedNonce() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringPtrOutput { return v.EncryptedNonce }).(pulumi.StringPtrOutput)
}

// Public or Private
func (o KmsKeyWithPolicyOverridesOutput) EndpointType() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.EndpointType }).(pulumi.StringOutput)
}

// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
func (o KmsKeyWithPolicyOverridesOutput) ExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringPtrOutput { return v.ExpirationDate }).(pulumi.StringPtrOutput)
}

// set to true to force delete the key
func (o KmsKeyWithPolicyOverridesOutput) ForceDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.BoolPtrOutput { return v.ForceDelete }).(pulumi.BoolPtrOutput)
}

// Key protect or HPCS instance CRN
func (o KmsKeyWithPolicyOverridesOutput) InstanceCrn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.InstanceCrn }).(pulumi.StringOutput)
}

// Key protect or HPCS instance GUID or CRN
func (o KmsKeyWithPolicyOverridesOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// Only for imported root key
func (o KmsKeyWithPolicyOverridesOutput) IvValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringPtrOutput { return v.IvValue }).(pulumi.StringPtrOutput)
}

// Key ID
func (o KmsKeyWithPolicyOverridesOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Key name
func (o KmsKeyWithPolicyOverridesOutput) KeyName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.KeyName }).(pulumi.StringOutput)
}

// Key Ring for the Key
func (o KmsKeyWithPolicyOverridesOutput) KeyRingId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringPtrOutput { return v.KeyRingId }).(pulumi.StringPtrOutput)
}

func (o KmsKeyWithPolicyOverridesOutput) Payload() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.Payload }).(pulumi.StringOutput)
}

// Registrations of the key across different services
func (o KmsKeyWithPolicyOverridesOutput) Registrations() KmsKeyWithPolicyOverridesRegistrationArrayOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) KmsKeyWithPolicyOverridesRegistrationArrayOutput {
		return v.Registrations
	}).(KmsKeyWithPolicyOverridesRegistrationArrayOutput)
}

// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
func (o KmsKeyWithPolicyOverridesOutput) ResourceControllerUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.ResourceControllerUrl }).(pulumi.StringOutput)
}

// The crn of the resource
func (o KmsKeyWithPolicyOverridesOutput) ResourceCrn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.ResourceCrn }).(pulumi.StringOutput)
}

// The resource group name in which resource is provisioned
func (o KmsKeyWithPolicyOverridesOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// The name of the resource
func (o KmsKeyWithPolicyOverridesOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.ResourceName }).(pulumi.StringOutput)
}

// The status of the resource
func (o KmsKeyWithPolicyOverridesOutput) ResourceStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.ResourceStatus }).(pulumi.StringOutput)
}

// Data associated with the key rotation policy
func (o KmsKeyWithPolicyOverridesOutput) Rotations() KmsKeyWithPolicyOverridesRotationArrayOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) KmsKeyWithPolicyOverridesRotationArrayOutput { return v.Rotations }).(KmsKeyWithPolicyOverridesRotationArrayOutput)
}

// Standard key type
func (o KmsKeyWithPolicyOverridesOutput) StandardKey() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.BoolPtrOutput { return v.StandardKey }).(pulumi.BoolPtrOutput)
}

// Type of service hs-crypto or kms
func (o KmsKeyWithPolicyOverridesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKeyWithPolicyOverrides) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type KmsKeyWithPolicyOverridesArrayOutput struct{ *pulumi.OutputState }

func (KmsKeyWithPolicyOverridesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (o KmsKeyWithPolicyOverridesArrayOutput) ToKmsKeyWithPolicyOverridesArrayOutput() KmsKeyWithPolicyOverridesArrayOutput {
	return o
}

func (o KmsKeyWithPolicyOverridesArrayOutput) ToKmsKeyWithPolicyOverridesArrayOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesArrayOutput {
	return o
}

func (o KmsKeyWithPolicyOverridesArrayOutput) Index(i pulumi.IntInput) KmsKeyWithPolicyOverridesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KmsKeyWithPolicyOverrides {
		return vs[0].([]*KmsKeyWithPolicyOverrides)[vs[1].(int)]
	}).(KmsKeyWithPolicyOverridesOutput)
}

type KmsKeyWithPolicyOverridesMapOutput struct{ *pulumi.OutputState }

func (KmsKeyWithPolicyOverridesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKeyWithPolicyOverrides)(nil)).Elem()
}

func (o KmsKeyWithPolicyOverridesMapOutput) ToKmsKeyWithPolicyOverridesMapOutput() KmsKeyWithPolicyOverridesMapOutput {
	return o
}

func (o KmsKeyWithPolicyOverridesMapOutput) ToKmsKeyWithPolicyOverridesMapOutputWithContext(ctx context.Context) KmsKeyWithPolicyOverridesMapOutput {
	return o
}

func (o KmsKeyWithPolicyOverridesMapOutput) MapIndex(k pulumi.StringInput) KmsKeyWithPolicyOverridesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KmsKeyWithPolicyOverrides {
		return vs[0].(map[string]*KmsKeyWithPolicyOverrides)[vs[1].(string)]
	}).(KmsKeyWithPolicyOverridesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyWithPolicyOverridesInput)(nil)).Elem(), &KmsKeyWithPolicyOverrides{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyWithPolicyOverridesArrayInput)(nil)).Elem(), KmsKeyWithPolicyOverridesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyWithPolicyOverridesMapInput)(nil)).Elem(), KmsKeyWithPolicyOverridesMap{})
	pulumi.RegisterOutputType(KmsKeyWithPolicyOverridesOutput{})
	pulumi.RegisterOutputType(KmsKeyWithPolicyOverridesArrayOutput{})
	pulumi.RegisterOutputType(KmsKeyWithPolicyOverridesMapOutput{})
}
