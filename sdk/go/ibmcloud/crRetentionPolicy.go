// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ibmcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/mapt-oss/pulumi-ibmcloud/sdk/go/ibmcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type CrRetentionPolicy struct {
	pulumi.CustomResourceState

	// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
	ImagesPerRepo pulumi.IntOutput `pulumi:"imagesPerRepo"`
	// The namespace to which the retention policy is attached.
	Namespace pulumi.StringOutput `pulumi:"namespace"`
	// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
	RetainUntagged pulumi.BoolPtrOutput `pulumi:"retainUntagged"`
}

// NewCrRetentionPolicy registers a new resource with the given unique name, arguments, and options.
func NewCrRetentionPolicy(ctx *pulumi.Context,
	name string, args *CrRetentionPolicyArgs, opts ...pulumi.ResourceOption) (*CrRetentionPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ImagesPerRepo == nil {
		return nil, errors.New("invalid value for required argument 'ImagesPerRepo'")
	}
	if args.Namespace == nil {
		return nil, errors.New("invalid value for required argument 'Namespace'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CrRetentionPolicy
	err := ctx.RegisterResource("ibmcloud:index/crRetentionPolicy:CrRetentionPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCrRetentionPolicy gets an existing CrRetentionPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCrRetentionPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CrRetentionPolicyState, opts ...pulumi.ResourceOption) (*CrRetentionPolicy, error) {
	var resource CrRetentionPolicy
	err := ctx.ReadResource("ibmcloud:index/crRetentionPolicy:CrRetentionPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CrRetentionPolicy resources.
type crRetentionPolicyState struct {
	// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
	ImagesPerRepo *int `pulumi:"imagesPerRepo"`
	// The namespace to which the retention policy is attached.
	Namespace *string `pulumi:"namespace"`
	// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
	RetainUntagged *bool `pulumi:"retainUntagged"`
}

type CrRetentionPolicyState struct {
	// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
	ImagesPerRepo pulumi.IntPtrInput
	// The namespace to which the retention policy is attached.
	Namespace pulumi.StringPtrInput
	// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
	RetainUntagged pulumi.BoolPtrInput
}

func (CrRetentionPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*crRetentionPolicyState)(nil)).Elem()
}

type crRetentionPolicyArgs struct {
	// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
	ImagesPerRepo int `pulumi:"imagesPerRepo"`
	// The namespace to which the retention policy is attached.
	Namespace string `pulumi:"namespace"`
	// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
	RetainUntagged *bool `pulumi:"retainUntagged"`
}

// The set of arguments for constructing a CrRetentionPolicy resource.
type CrRetentionPolicyArgs struct {
	// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
	ImagesPerRepo pulumi.IntInput
	// The namespace to which the retention policy is attached.
	Namespace pulumi.StringInput
	// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
	RetainUntagged pulumi.BoolPtrInput
}

func (CrRetentionPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*crRetentionPolicyArgs)(nil)).Elem()
}

type CrRetentionPolicyInput interface {
	pulumi.Input

	ToCrRetentionPolicyOutput() CrRetentionPolicyOutput
	ToCrRetentionPolicyOutputWithContext(ctx context.Context) CrRetentionPolicyOutput
}

func (*CrRetentionPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**CrRetentionPolicy)(nil)).Elem()
}

func (i *CrRetentionPolicy) ToCrRetentionPolicyOutput() CrRetentionPolicyOutput {
	return i.ToCrRetentionPolicyOutputWithContext(context.Background())
}

func (i *CrRetentionPolicy) ToCrRetentionPolicyOutputWithContext(ctx context.Context) CrRetentionPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrRetentionPolicyOutput)
}

// CrRetentionPolicyArrayInput is an input type that accepts CrRetentionPolicyArray and CrRetentionPolicyArrayOutput values.
// You can construct a concrete instance of `CrRetentionPolicyArrayInput` via:
//
//	CrRetentionPolicyArray{ CrRetentionPolicyArgs{...} }
type CrRetentionPolicyArrayInput interface {
	pulumi.Input

	ToCrRetentionPolicyArrayOutput() CrRetentionPolicyArrayOutput
	ToCrRetentionPolicyArrayOutputWithContext(context.Context) CrRetentionPolicyArrayOutput
}

type CrRetentionPolicyArray []CrRetentionPolicyInput

func (CrRetentionPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CrRetentionPolicy)(nil)).Elem()
}

func (i CrRetentionPolicyArray) ToCrRetentionPolicyArrayOutput() CrRetentionPolicyArrayOutput {
	return i.ToCrRetentionPolicyArrayOutputWithContext(context.Background())
}

func (i CrRetentionPolicyArray) ToCrRetentionPolicyArrayOutputWithContext(ctx context.Context) CrRetentionPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrRetentionPolicyArrayOutput)
}

// CrRetentionPolicyMapInput is an input type that accepts CrRetentionPolicyMap and CrRetentionPolicyMapOutput values.
// You can construct a concrete instance of `CrRetentionPolicyMapInput` via:
//
//	CrRetentionPolicyMap{ "key": CrRetentionPolicyArgs{...} }
type CrRetentionPolicyMapInput interface {
	pulumi.Input

	ToCrRetentionPolicyMapOutput() CrRetentionPolicyMapOutput
	ToCrRetentionPolicyMapOutputWithContext(context.Context) CrRetentionPolicyMapOutput
}

type CrRetentionPolicyMap map[string]CrRetentionPolicyInput

func (CrRetentionPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CrRetentionPolicy)(nil)).Elem()
}

func (i CrRetentionPolicyMap) ToCrRetentionPolicyMapOutput() CrRetentionPolicyMapOutput {
	return i.ToCrRetentionPolicyMapOutputWithContext(context.Background())
}

func (i CrRetentionPolicyMap) ToCrRetentionPolicyMapOutputWithContext(ctx context.Context) CrRetentionPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrRetentionPolicyMapOutput)
}

type CrRetentionPolicyOutput struct{ *pulumi.OutputState }

func (CrRetentionPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CrRetentionPolicy)(nil)).Elem()
}

func (o CrRetentionPolicyOutput) ToCrRetentionPolicyOutput() CrRetentionPolicyOutput {
	return o
}

func (o CrRetentionPolicyOutput) ToCrRetentionPolicyOutputWithContext(ctx context.Context) CrRetentionPolicyOutput {
	return o
}

// Determines how many images will be retained for each repository when the retention policy is executed. The value -1 denotes 'Unlimited' (all images are retained).
func (o CrRetentionPolicyOutput) ImagesPerRepo() pulumi.IntOutput {
	return o.ApplyT(func(v *CrRetentionPolicy) pulumi.IntOutput { return v.ImagesPerRepo }).(pulumi.IntOutput)
}

// The namespace to which the retention policy is attached.
func (o CrRetentionPolicyOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v *CrRetentionPolicy) pulumi.StringOutput { return v.Namespace }).(pulumi.StringOutput)
}

// Determines if untagged images are retained when executing the retention policy. This is false by default meaning untagged images will be deleted when the policy is executed.
func (o CrRetentionPolicyOutput) RetainUntagged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CrRetentionPolicy) pulumi.BoolPtrOutput { return v.RetainUntagged }).(pulumi.BoolPtrOutput)
}

type CrRetentionPolicyArrayOutput struct{ *pulumi.OutputState }

func (CrRetentionPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CrRetentionPolicy)(nil)).Elem()
}

func (o CrRetentionPolicyArrayOutput) ToCrRetentionPolicyArrayOutput() CrRetentionPolicyArrayOutput {
	return o
}

func (o CrRetentionPolicyArrayOutput) ToCrRetentionPolicyArrayOutputWithContext(ctx context.Context) CrRetentionPolicyArrayOutput {
	return o
}

func (o CrRetentionPolicyArrayOutput) Index(i pulumi.IntInput) CrRetentionPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CrRetentionPolicy {
		return vs[0].([]*CrRetentionPolicy)[vs[1].(int)]
	}).(CrRetentionPolicyOutput)
}

type CrRetentionPolicyMapOutput struct{ *pulumi.OutputState }

func (CrRetentionPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CrRetentionPolicy)(nil)).Elem()
}

func (o CrRetentionPolicyMapOutput) ToCrRetentionPolicyMapOutput() CrRetentionPolicyMapOutput {
	return o
}

func (o CrRetentionPolicyMapOutput) ToCrRetentionPolicyMapOutputWithContext(ctx context.Context) CrRetentionPolicyMapOutput {
	return o
}

func (o CrRetentionPolicyMapOutput) MapIndex(k pulumi.StringInput) CrRetentionPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CrRetentionPolicy {
		return vs[0].(map[string]*CrRetentionPolicy)[vs[1].(string)]
	}).(CrRetentionPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CrRetentionPolicyInput)(nil)).Elem(), &CrRetentionPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*CrRetentionPolicyArrayInput)(nil)).Elem(), CrRetentionPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CrRetentionPolicyMapInput)(nil)).Elem(), CrRetentionPolicyMap{})
	pulumi.RegisterOutputType(CrRetentionPolicyOutput{})
	pulumi.RegisterOutputType(CrRetentionPolicyArrayOutput{})
	pulumi.RegisterOutputType(CrRetentionPolicyMapOutput{})
}
