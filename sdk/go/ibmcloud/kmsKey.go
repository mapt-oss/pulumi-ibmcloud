// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ibmcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/mapt-oss/pulumi-ibmcloud/sdk/go/ibmcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type KmsKey struct {
	pulumi.CustomResourceState

	// Crn of the key
	Crn pulumi.StringOutput `pulumi:"crn"`
	// description of the key
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrOutput `pulumi:"encryptedNonce"`
	// public or private
	EndpointType pulumi.StringOutput `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrOutput `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrOutput `pulumi:"forceDelete"`
	// Key protect or hpcs instance CRN
	InstanceCrn pulumi.StringOutput `pulumi:"instanceCrn"`
	// Key protect or hpcs instance GUID or CRN
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// Only for imported root key
	IvValue pulumi.StringPtrOutput `pulumi:"ivValue"`
	// Key ID
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Key name
	KeyName pulumi.StringOutput `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrOutput `pulumi:"keyRingId"`
	Payload   pulumi.StringOutput    `pulumi:"payload"`
	// Registrations of the key across different services
	Registrations KmsKeyRegistrationArrayOutput `pulumi:"registrations"`
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl pulumi.StringOutput `pulumi:"resourceControllerUrl"`
	// The crn of the resource
	ResourceCrn pulumi.StringOutput `pulumi:"resourceCrn"`
	// The resource group name in which resource is provisioned
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// The name of the resource
	ResourceName pulumi.StringOutput `pulumi:"resourceName"`
	// The status of the resource
	ResourceStatus pulumi.StringOutput `pulumi:"resourceStatus"`
	// Standard key type
	StandardKey pulumi.BoolPtrOutput `pulumi:"standardKey"`
	// type of service hs-crypto or kms
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewKmsKey registers a new resource with the given unique name, arguments, and options.
func NewKmsKey(ctx *pulumi.Context,
	name string, args *KmsKeyArgs, opts ...pulumi.ResourceOption) (*KmsKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.KeyName == nil {
		return nil, errors.New("invalid value for required argument 'KeyName'")
	}
	if args.Payload != nil {
		args.Payload = pulumi.ToSecret(args.Payload).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"payload",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KmsKey
	err := ctx.RegisterResource("ibmcloud:index/kmsKey:KmsKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsKey gets an existing KmsKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsKeyState, opts ...pulumi.ResourceOption) (*KmsKey, error) {
	var resource KmsKey
	err := ctx.ReadResource("ibmcloud:index/kmsKey:KmsKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsKey resources.
type kmsKeyState struct {
	// Crn of the key
	Crn *string `pulumi:"crn"`
	// description of the key
	Description *string `pulumi:"description"`
	// Only for imported root key
	EncryptedNonce *string `pulumi:"encryptedNonce"`
	// public or private
	EndpointType *string `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate *string `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete *bool `pulumi:"forceDelete"`
	// Key protect or hpcs instance CRN
	InstanceCrn *string `pulumi:"instanceCrn"`
	// Key protect or hpcs instance GUID or CRN
	InstanceId *string `pulumi:"instanceId"`
	// Only for imported root key
	IvValue *string `pulumi:"ivValue"`
	// Key ID
	KeyId *string `pulumi:"keyId"`
	// Key name
	KeyName *string `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId *string `pulumi:"keyRingId"`
	Payload   *string `pulumi:"payload"`
	// Registrations of the key across different services
	Registrations []KmsKeyRegistration `pulumi:"registrations"`
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl *string `pulumi:"resourceControllerUrl"`
	// The crn of the resource
	ResourceCrn *string `pulumi:"resourceCrn"`
	// The resource group name in which resource is provisioned
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// The name of the resource
	ResourceName *string `pulumi:"resourceName"`
	// The status of the resource
	ResourceStatus *string `pulumi:"resourceStatus"`
	// Standard key type
	StandardKey *bool `pulumi:"standardKey"`
	// type of service hs-crypto or kms
	Type *string `pulumi:"type"`
}

type KmsKeyState struct {
	// Crn of the key
	Crn pulumi.StringPtrInput
	// description of the key
	Description pulumi.StringPtrInput
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrInput
	// public or private
	EndpointType pulumi.StringPtrInput
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrInput
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrInput
	// Key protect or hpcs instance CRN
	InstanceCrn pulumi.StringPtrInput
	// Key protect or hpcs instance GUID or CRN
	InstanceId pulumi.StringPtrInput
	// Only for imported root key
	IvValue pulumi.StringPtrInput
	// Key ID
	KeyId pulumi.StringPtrInput
	// Key name
	KeyName pulumi.StringPtrInput
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrInput
	Payload   pulumi.StringPtrInput
	// Registrations of the key across different services
	Registrations KmsKeyRegistrationArrayInput
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
	ResourceControllerUrl pulumi.StringPtrInput
	// The crn of the resource
	ResourceCrn pulumi.StringPtrInput
	// The resource group name in which resource is provisioned
	ResourceGroupName pulumi.StringPtrInput
	// The name of the resource
	ResourceName pulumi.StringPtrInput
	// The status of the resource
	ResourceStatus pulumi.StringPtrInput
	// Standard key type
	StandardKey pulumi.BoolPtrInput
	// type of service hs-crypto or kms
	Type pulumi.StringPtrInput
}

func (KmsKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyState)(nil)).Elem()
}

type kmsKeyArgs struct {
	// description of the key
	Description *string `pulumi:"description"`
	// Only for imported root key
	EncryptedNonce *string `pulumi:"encryptedNonce"`
	// public or private
	EndpointType *string `pulumi:"endpointType"`
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate *string `pulumi:"expirationDate"`
	// set to true to force delete the key
	ForceDelete *bool `pulumi:"forceDelete"`
	// Key protect or hpcs instance GUID or CRN
	InstanceId string `pulumi:"instanceId"`
	// Only for imported root key
	IvValue *string `pulumi:"ivValue"`
	// Key name
	KeyName string `pulumi:"keyName"`
	// Key Ring for the Key
	KeyRingId *string `pulumi:"keyRingId"`
	Payload   *string `pulumi:"payload"`
	// Standard key type
	StandardKey *bool `pulumi:"standardKey"`
}

// The set of arguments for constructing a KmsKey resource.
type KmsKeyArgs struct {
	// description of the key
	Description pulumi.StringPtrInput
	// Only for imported root key
	EncryptedNonce pulumi.StringPtrInput
	// public or private
	EndpointType pulumi.StringPtrInput
	// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
	ExpirationDate pulumi.StringPtrInput
	// set to true to force delete the key
	ForceDelete pulumi.BoolPtrInput
	// Key protect or hpcs instance GUID or CRN
	InstanceId pulumi.StringInput
	// Only for imported root key
	IvValue pulumi.StringPtrInput
	// Key name
	KeyName pulumi.StringInput
	// Key Ring for the Key
	KeyRingId pulumi.StringPtrInput
	Payload   pulumi.StringPtrInput
	// Standard key type
	StandardKey pulumi.BoolPtrInput
}

func (KmsKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyArgs)(nil)).Elem()
}

type KmsKeyInput interface {
	pulumi.Input

	ToKmsKeyOutput() KmsKeyOutput
	ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput
}

func (*KmsKey) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKey)(nil)).Elem()
}

func (i *KmsKey) ToKmsKeyOutput() KmsKeyOutput {
	return i.ToKmsKeyOutputWithContext(context.Background())
}

func (i *KmsKey) ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyOutput)
}

// KmsKeyArrayInput is an input type that accepts KmsKeyArray and KmsKeyArrayOutput values.
// You can construct a concrete instance of `KmsKeyArrayInput` via:
//
//	KmsKeyArray{ KmsKeyArgs{...} }
type KmsKeyArrayInput interface {
	pulumi.Input

	ToKmsKeyArrayOutput() KmsKeyArrayOutput
	ToKmsKeyArrayOutputWithContext(context.Context) KmsKeyArrayOutput
}

type KmsKeyArray []KmsKeyInput

func (KmsKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKey)(nil)).Elem()
}

func (i KmsKeyArray) ToKmsKeyArrayOutput() KmsKeyArrayOutput {
	return i.ToKmsKeyArrayOutputWithContext(context.Background())
}

func (i KmsKeyArray) ToKmsKeyArrayOutputWithContext(ctx context.Context) KmsKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyArrayOutput)
}

// KmsKeyMapInput is an input type that accepts KmsKeyMap and KmsKeyMapOutput values.
// You can construct a concrete instance of `KmsKeyMapInput` via:
//
//	KmsKeyMap{ "key": KmsKeyArgs{...} }
type KmsKeyMapInput interface {
	pulumi.Input

	ToKmsKeyMapOutput() KmsKeyMapOutput
	ToKmsKeyMapOutputWithContext(context.Context) KmsKeyMapOutput
}

type KmsKeyMap map[string]KmsKeyInput

func (KmsKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKey)(nil)).Elem()
}

func (i KmsKeyMap) ToKmsKeyMapOutput() KmsKeyMapOutput {
	return i.ToKmsKeyMapOutputWithContext(context.Background())
}

func (i KmsKeyMap) ToKmsKeyMapOutputWithContext(ctx context.Context) KmsKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyMapOutput)
}

type KmsKeyOutput struct{ *pulumi.OutputState }

func (KmsKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKey)(nil)).Elem()
}

func (o KmsKeyOutput) ToKmsKeyOutput() KmsKeyOutput {
	return o
}

func (o KmsKeyOutput) ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput {
	return o
}

// Crn of the key
func (o KmsKeyOutput) Crn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Crn }).(pulumi.StringOutput)
}

// description of the key
func (o KmsKeyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Only for imported root key
func (o KmsKeyOutput) EncryptedNonce() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.EncryptedNonce }).(pulumi.StringPtrOutput)
}

// public or private
func (o KmsKeyOutput) EndpointType() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.EndpointType }).(pulumi.StringOutput)
}

// The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example 2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data, even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a deactivated key does not move it back to the Active state. If the expirationDate attribute is omitted, the key does not expire.
func (o KmsKeyOutput) ExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.ExpirationDate }).(pulumi.StringPtrOutput)
}

// set to true to force delete the key
func (o KmsKeyOutput) ForceDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.BoolPtrOutput { return v.ForceDelete }).(pulumi.BoolPtrOutput)
}

// Key protect or hpcs instance CRN
func (o KmsKeyOutput) InstanceCrn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.InstanceCrn }).(pulumi.StringOutput)
}

// Key protect or hpcs instance GUID or CRN
func (o KmsKeyOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// Only for imported root key
func (o KmsKeyOutput) IvValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.IvValue }).(pulumi.StringPtrOutput)
}

// Key ID
func (o KmsKeyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Key name
func (o KmsKeyOutput) KeyName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.KeyName }).(pulumi.StringOutput)
}

// Key Ring for the Key
func (o KmsKeyOutput) KeyRingId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.KeyRingId }).(pulumi.StringPtrOutput)
}

func (o KmsKeyOutput) Payload() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Payload }).(pulumi.StringOutput)
}

// Registrations of the key across different services
func (o KmsKeyOutput) Registrations() KmsKeyRegistrationArrayOutput {
	return o.ApplyT(func(v *KmsKey) KmsKeyRegistrationArrayOutput { return v.Registrations }).(KmsKeyRegistrationArrayOutput)
}

// The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
func (o KmsKeyOutput) ResourceControllerUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ResourceControllerUrl }).(pulumi.StringOutput)
}

// The crn of the resource
func (o KmsKeyOutput) ResourceCrn() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ResourceCrn }).(pulumi.StringOutput)
}

// The resource group name in which resource is provisioned
func (o KmsKeyOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// The name of the resource
func (o KmsKeyOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ResourceName }).(pulumi.StringOutput)
}

// The status of the resource
func (o KmsKeyOutput) ResourceStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ResourceStatus }).(pulumi.StringOutput)
}

// Standard key type
func (o KmsKeyOutput) StandardKey() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.BoolPtrOutput { return v.StandardKey }).(pulumi.BoolPtrOutput)
}

// type of service hs-crypto or kms
func (o KmsKeyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type KmsKeyArrayOutput struct{ *pulumi.OutputState }

func (KmsKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKey)(nil)).Elem()
}

func (o KmsKeyArrayOutput) ToKmsKeyArrayOutput() KmsKeyArrayOutput {
	return o
}

func (o KmsKeyArrayOutput) ToKmsKeyArrayOutputWithContext(ctx context.Context) KmsKeyArrayOutput {
	return o
}

func (o KmsKeyArrayOutput) Index(i pulumi.IntInput) KmsKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KmsKey {
		return vs[0].([]*KmsKey)[vs[1].(int)]
	}).(KmsKeyOutput)
}

type KmsKeyMapOutput struct{ *pulumi.OutputState }

func (KmsKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKey)(nil)).Elem()
}

func (o KmsKeyMapOutput) ToKmsKeyMapOutput() KmsKeyMapOutput {
	return o
}

func (o KmsKeyMapOutput) ToKmsKeyMapOutputWithContext(ctx context.Context) KmsKeyMapOutput {
	return o
}

func (o KmsKeyMapOutput) MapIndex(k pulumi.StringInput) KmsKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KmsKey {
		return vs[0].(map[string]*KmsKey)[vs[1].(string)]
	}).(KmsKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyInput)(nil)).Elem(), &KmsKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyArrayInput)(nil)).Elem(), KmsKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyMapInput)(nil)).Elem(), KmsKeyMap{})
	pulumi.RegisterOutputType(KmsKeyOutput{})
	pulumi.RegisterOutputType(KmsKeyArrayOutput{})
	pulumi.RegisterOutputType(KmsKeyMapOutput{})
}
