# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = ['SmPrivateCertificateConfigurationTemplateArgs', 'SmPrivateCertificateConfigurationTemplate']

@pulumi.input_type
class SmPrivateCertificateConfigurationTemplateArgs:
    def __init__(__self__, *,
                 certificate_authority: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 allow_any_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_bare_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_glob_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_ip_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_localhost: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_wildcard_certificates: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_domains_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_secret_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 allowed_uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 basic_constraints_valid_for_non_ca: Optional[pulumi.Input[_builtins.bool]] = None,
                 client_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 code_signing_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_protection_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_hostnames: Optional[pulumi.Input[_builtins.bool]] = None,
                 ext_key_usage_oids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ext_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 key_bits: Optional[pulumi.Input[_builtins.int]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 localities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 organizations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ous: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policy_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 postal_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provinces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 require_cn: Optional[pulumi.Input[_builtins.bool]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 server_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 street_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 use_csr_common_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_csr_sans: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The set of arguments for constructing a SmPrivateCertificateConfigurationTemplate resource.
        :param pulumi.Input[_builtins.str] certificate_authority: The name of the intermediate certificate authority.
        :param pulumi.Input[_builtins.str] instance_id: The ID of the Secrets Manager instance.
        :param pulumi.Input[_builtins.bool] allow_any_name: Determines whether to allow clients to request a private certificate that matches any common name.
        :param pulumi.Input[_builtins.bool] allow_bare_domains: Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        :param pulumi.Input[_builtins.bool] allow_glob_domains: Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        :param pulumi.Input[_builtins.bool] allow_ip_sans: Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        :param pulumi.Input[_builtins.bool] allow_localhost: Determines whether to allow `localhost` to be included as one of the requested common names.
        :param pulumi.Input[_builtins.bool] allow_subdomains: Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        :param pulumi.Input[_builtins.bool] allow_wildcard_certificates: Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_domains: The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        :param pulumi.Input[_builtins.bool] allowed_domains_template: Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_other_sans: The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        :param pulumi.Input[_builtins.str] allowed_secret_groups: Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_uri_sans: The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        :param pulumi.Input[_builtins.bool] basic_constraints_valid_for_non_ca: Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        :param pulumi.Input[_builtins.bool] client_flag: Determines whether private certificates are flagged for client use.
        :param pulumi.Input[_builtins.bool] code_signing_flag: Determines whether private certificates are flagged for code signing use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] countries: The Country (C) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.bool] email_protection_flag: Determines whether private certificates are flagged for email protection use.
        :param pulumi.Input[_builtins.str] endpoint_type: public or private.
        :param pulumi.Input[_builtins.bool] enforce_hostnames: Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usage_oids: A list of extended key usage Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usages: The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[_builtins.int] key_bits: The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        :param pulumi.Input[_builtins.str] key_type: The type of private key to generate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_usages: The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] localities: The Locality (L) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] max_ttl: The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param pulumi.Input[_builtins.str] name: A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        :param pulumi.Input[_builtins.str] not_before_duration: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] organizations: The Organization (O) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ous: The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_identifiers: A list of policy Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] postal_codes: The postal code values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] provinces: The Province (ST) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] region: The region of the Secrets Manager instance.
        :param pulumi.Input[_builtins.bool] require_cn: Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        :param pulumi.Input[_builtins.str] serial_number: Unused field.
        :param pulumi.Input[_builtins.bool] server_flag: Determines whether private certificates are flagged for server use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] street_addresses: The street address values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] ttl: The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.bool] use_csr_common_name: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        :param pulumi.Input[_builtins.bool] use_csr_sans: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "instance_id", instance_id)
        if allow_any_name is not None:
            pulumi.set(__self__, "allow_any_name", allow_any_name)
        if allow_bare_domains is not None:
            pulumi.set(__self__, "allow_bare_domains", allow_bare_domains)
        if allow_glob_domains is not None:
            pulumi.set(__self__, "allow_glob_domains", allow_glob_domains)
        if allow_ip_sans is not None:
            pulumi.set(__self__, "allow_ip_sans", allow_ip_sans)
        if allow_localhost is not None:
            pulumi.set(__self__, "allow_localhost", allow_localhost)
        if allow_subdomains is not None:
            pulumi.set(__self__, "allow_subdomains", allow_subdomains)
        if allow_wildcard_certificates is not None:
            pulumi.set(__self__, "allow_wildcard_certificates", allow_wildcard_certificates)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_domains_template is not None:
            pulumi.set(__self__, "allowed_domains_template", allowed_domains_template)
        if allowed_other_sans is not None:
            pulumi.set(__self__, "allowed_other_sans", allowed_other_sans)
        if allowed_secret_groups is not None:
            pulumi.set(__self__, "allowed_secret_groups", allowed_secret_groups)
        if allowed_uri_sans is not None:
            pulumi.set(__self__, "allowed_uri_sans", allowed_uri_sans)
        if basic_constraints_valid_for_non_ca is not None:
            pulumi.set(__self__, "basic_constraints_valid_for_non_ca", basic_constraints_valid_for_non_ca)
        if client_flag is not None:
            pulumi.set(__self__, "client_flag", client_flag)
        if code_signing_flag is not None:
            pulumi.set(__self__, "code_signing_flag", code_signing_flag)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)
        if email_protection_flag is not None:
            pulumi.set(__self__, "email_protection_flag", email_protection_flag)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if enforce_hostnames is not None:
            pulumi.set(__self__, "enforce_hostnames", enforce_hostnames)
        if ext_key_usage_oids is not None:
            pulumi.set(__self__, "ext_key_usage_oids", ext_key_usage_oids)
        if ext_key_usages is not None:
            pulumi.set(__self__, "ext_key_usages", ext_key_usages)
        if key_bits is not None:
            pulumi.set(__self__, "key_bits", key_bits)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if key_usages is not None:
            pulumi.set(__self__, "key_usages", key_usages)
        if localities is not None:
            pulumi.set(__self__, "localities", localities)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if not_before_duration is not None:
            pulumi.set(__self__, "not_before_duration", not_before_duration)
        if organizations is not None:
            pulumi.set(__self__, "organizations", organizations)
        if ous is not None:
            pulumi.set(__self__, "ous", ous)
        if policy_identifiers is not None:
            pulumi.set(__self__, "policy_identifiers", policy_identifiers)
        if postal_codes is not None:
            pulumi.set(__self__, "postal_codes", postal_codes)
        if provinces is not None:
            pulumi.set(__self__, "provinces", provinces)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if require_cn is not None:
            pulumi.set(__self__, "require_cn", require_cn)
        if serial_number is not None:
            warnings.warn("""This field is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""serial_number is deprecated: This field is deprecated.""")
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if server_flag is not None:
            pulumi.set(__self__, "server_flag", server_flag)
        if street_addresses is not None:
            pulumi.set(__self__, "street_addresses", street_addresses)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if use_csr_common_name is not None:
            pulumi.set(__self__, "use_csr_common_name", use_csr_common_name)
        if use_csr_sans is not None:
            pulumi.set(__self__, "use_csr_sans", use_csr_sans)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the intermediate certificate authority.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Secrets Manager instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="allowAnyName")
    def allow_any_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request a private certificate that matches any common name.
        """
        return pulumi.get(self, "allow_any_name")

    @allow_any_name.setter
    def allow_any_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_any_name", value)

    @_builtins.property
    @pulumi.getter(name="allowBareDomains")
    def allow_bare_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        """
        return pulumi.get(self, "allow_bare_domains")

    @allow_bare_domains.setter
    def allow_bare_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_bare_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowGlobDomains")
    def allow_glob_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        """
        return pulumi.get(self, "allow_glob_domains")

    @allow_glob_domains.setter
    def allow_glob_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_glob_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowIpSans")
    def allow_ip_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        """
        return pulumi.get(self, "allow_ip_sans")

    @allow_ip_sans.setter
    def allow_ip_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_ip_sans", value)

    @_builtins.property
    @pulumi.getter(name="allowLocalhost")
    def allow_localhost(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow `localhost` to be included as one of the requested common names.
        """
        return pulumi.get(self, "allow_localhost")

    @allow_localhost.setter
    def allow_localhost(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_localhost", value)

    @_builtins.property
    @pulumi.getter(name="allowSubdomains")
    def allow_subdomains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        """
        return pulumi.get(self, "allow_subdomains")

    @allow_subdomains.setter
    def allow_subdomains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="allowWildcardCertificates")
    def allow_wildcard_certificates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        """
        return pulumi.get(self, "allow_wildcard_certificates")

    @allow_wildcard_certificates.setter
    def allow_wildcard_certificates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_wildcard_certificates", value)

    @_builtins.property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowedDomainsTemplate")
    def allowed_domains_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        """
        return pulumi.get(self, "allowed_domains_template")

    @allowed_domains_template.setter
    def allowed_domains_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allowed_domains_template", value)

    @_builtins.property
    @pulumi.getter(name="allowedOtherSans")
    def allowed_other_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        """
        return pulumi.get(self, "allowed_other_sans")

    @allowed_other_sans.setter
    def allowed_other_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_other_sans", value)

    @_builtins.property
    @pulumi.getter(name="allowedSecretGroups")
    def allowed_secret_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        """
        return pulumi.get(self, "allowed_secret_groups")

    @allowed_secret_groups.setter
    def allowed_secret_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allowed_secret_groups", value)

    @_builtins.property
    @pulumi.getter(name="allowedUriSans")
    def allowed_uri_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        """
        return pulumi.get(self, "allowed_uri_sans")

    @allowed_uri_sans.setter
    def allowed_uri_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_uri_sans", value)

    @_builtins.property
    @pulumi.getter(name="basicConstraintsValidForNonCa")
    def basic_constraints_valid_for_non_ca(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        """
        return pulumi.get(self, "basic_constraints_valid_for_non_ca")

    @basic_constraints_valid_for_non_ca.setter
    def basic_constraints_valid_for_non_ca(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "basic_constraints_valid_for_non_ca", value)

    @_builtins.property
    @pulumi.getter(name="clientFlag")
    def client_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for client use.
        """
        return pulumi.get(self, "client_flag")

    @client_flag.setter
    def client_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "client_flag", value)

    @_builtins.property
    @pulumi.getter(name="codeSigningFlag")
    def code_signing_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for code signing use.
        """
        return pulumi.get(self, "code_signing_flag")

    @code_signing_flag.setter
    def code_signing_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "code_signing_flag", value)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Country (C) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "countries", value)

    @_builtins.property
    @pulumi.getter(name="emailProtectionFlag")
    def email_protection_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for email protection use.
        """
        return pulumi.get(self, "email_protection_flag")

    @email_protection_flag.setter
    def email_protection_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "email_protection_flag", value)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        public or private.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="enforceHostnames")
    def enforce_hostnames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        """
        return pulumi.get(self, "enforce_hostnames")

    @enforce_hostnames.setter
    def enforce_hostnames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="extKeyUsageOids")
    def ext_key_usage_oids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of extended key usage Object Identifiers (OIDs).
        """
        return pulumi.get(self, "ext_key_usage_oids")

    @ext_key_usage_oids.setter
    def ext_key_usage_oids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ext_key_usage_oids", value)

    @_builtins.property
    @pulumi.getter(name="extKeyUsages")
    def ext_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "ext_key_usages")

    @ext_key_usages.setter
    def ext_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ext_key_usages", value)

    @_builtins.property
    @pulumi.getter(name="keyBits")
    def key_bits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        """
        return pulumi.get(self, "key_bits")

    @key_bits.setter
    def key_bits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_bits", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of private key to generate.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="keyUsages")
    def key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "key_usages")

    @key_usages.setter
    def key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_usages", value)

    @_builtins.property
    @pulumi.getter
    def localities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Locality (L) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "localities")

    @localities.setter
    def localities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "localities", value)

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        """
        return pulumi.get(self, "max_ttl")

    @max_ttl.setter
    def max_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_ttl", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="notBeforeDuration")
    def not_before_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "not_before_duration")

    @not_before_duration.setter
    def not_before_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_before_duration", value)

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Organization (O) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "organizations")

    @organizations.setter
    def organizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "organizations", value)

    @_builtins.property
    @pulumi.getter
    def ous(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "ous")

    @ous.setter
    def ous(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ous", value)

    @_builtins.property
    @pulumi.getter(name="policyIdentifiers")
    def policy_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of policy Object Identifiers (OIDs).
        """
        return pulumi.get(self, "policy_identifiers")

    @policy_identifiers.setter
    def policy_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_identifiers", value)

    @_builtins.property
    @pulumi.getter(name="postalCodes")
    def postal_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The postal code values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "postal_codes")

    @postal_codes.setter
    def postal_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "postal_codes", value)

    @_builtins.property
    @pulumi.getter
    def provinces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Province (ST) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "provinces")

    @provinces.setter
    def provinces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "provinces", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the Secrets Manager instance.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="requireCn")
    def require_cn(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        """
        return pulumi.get(self, "require_cn")

    @require_cn.setter
    def require_cn(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_cn", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    @_utilities.deprecated("""This field is deprecated.""")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unused field.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="serverFlag")
    def server_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for server use.
        """
        return pulumi.get(self, "server_flag")

    @server_flag.setter
    def server_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_flag", value)

    @_builtins.property
    @pulumi.getter(name="streetAddresses")
    def street_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The street address values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "street_addresses")

    @street_addresses.setter
    def street_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "street_addresses", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="useCsrCommonName")
    def use_csr_common_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        """
        return pulumi.get(self, "use_csr_common_name")

    @use_csr_common_name.setter
    def use_csr_common_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_csr_common_name", value)

    @_builtins.property
    @pulumi.getter(name="useCsrSans")
    def use_csr_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        return pulumi.get(self, "use_csr_sans")

    @use_csr_sans.setter
    def use_csr_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_csr_sans", value)


@pulumi.input_type
class _SmPrivateCertificateConfigurationTemplateState:
    def __init__(__self__, *,
                 allow_any_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_bare_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_glob_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_ip_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_localhost: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_wildcard_certificates: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_domains_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_secret_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 allowed_uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 basic_constraints_valid_for_non_ca: Optional[pulumi.Input[_builtins.bool]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 code_signing_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 config_type: Optional[pulumi.Input[_builtins.str]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 email_protection_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_hostnames: Optional[pulumi.Input[_builtins.bool]] = None,
                 ext_key_usage_oids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ext_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_bits: Optional[pulumi.Input[_builtins.int]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 localities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 max_ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before_duration_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 organizations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ous: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policy_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 postal_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provinces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 require_cn: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_type: Optional[pulumi.Input[_builtins.str]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 server_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 street_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 use_csr_common_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_csr_sans: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Input properties used for looking up and filtering SmPrivateCertificateConfigurationTemplate resources.
        :param pulumi.Input[_builtins.bool] allow_any_name: Determines whether to allow clients to request a private certificate that matches any common name.
        :param pulumi.Input[_builtins.bool] allow_bare_domains: Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        :param pulumi.Input[_builtins.bool] allow_glob_domains: Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        :param pulumi.Input[_builtins.bool] allow_ip_sans: Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        :param pulumi.Input[_builtins.bool] allow_localhost: Determines whether to allow `localhost` to be included as one of the requested common names.
        :param pulumi.Input[_builtins.bool] allow_subdomains: Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        :param pulumi.Input[_builtins.bool] allow_wildcard_certificates: Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_domains: The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        :param pulumi.Input[_builtins.bool] allowed_domains_template: Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_other_sans: The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        :param pulumi.Input[_builtins.str] allowed_secret_groups: Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_uri_sans: The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        :param pulumi.Input[_builtins.bool] basic_constraints_valid_for_non_ca: Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        :param pulumi.Input[_builtins.str] certificate_authority: The name of the intermediate certificate authority.
        :param pulumi.Input[_builtins.bool] client_flag: Determines whether private certificates are flagged for client use.
        :param pulumi.Input[_builtins.bool] code_signing_flag: Determines whether private certificates are flagged for code signing use.
        :param pulumi.Input[_builtins.str] config_type: The configuration type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] countries: The Country (C) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] created_at: The date when a resource was created. The date format follows RFC 3339.
        :param pulumi.Input[_builtins.str] created_by: The unique identifier that is associated with the entity that created the secret.
        :param pulumi.Input[_builtins.bool] email_protection_flag: Determines whether private certificates are flagged for email protection use.
        :param pulumi.Input[_builtins.str] endpoint_type: public or private.
        :param pulumi.Input[_builtins.bool] enforce_hostnames: Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usage_oids: A list of extended key usage Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usages: The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[_builtins.str] instance_id: The ID of the Secrets Manager instance.
        :param pulumi.Input[_builtins.int] key_bits: The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        :param pulumi.Input[_builtins.str] key_type: The type of private key to generate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_usages: The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] localities: The Locality (L) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] max_ttl: The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param pulumi.Input[_builtins.int] max_ttl_seconds: The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
        :param pulumi.Input[_builtins.str] name: A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        :param pulumi.Input[_builtins.str] not_before_duration: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.int] not_before_duration_seconds: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] organizations: The Organization (O) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ous: The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_identifiers: A list of policy Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] postal_codes: The postal code values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] provinces: The Province (ST) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] region: The region of the Secrets Manager instance.
        :param pulumi.Input[_builtins.bool] require_cn: Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        :param pulumi.Input[_builtins.str] secret_type: The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
        :param pulumi.Input[_builtins.str] serial_number: Unused field.
        :param pulumi.Input[_builtins.bool] server_flag: Determines whether private certificates are flagged for server use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] street_addresses: The street address values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] ttl: The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.int] ttl_seconds: The requested Time To Live, after which the certificate will be expired.
        :param pulumi.Input[_builtins.str] updated_at: The date when a resource was recently modified. The date format follows RFC 3339.
        :param pulumi.Input[_builtins.bool] use_csr_common_name: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        :param pulumi.Input[_builtins.bool] use_csr_sans: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        if allow_any_name is not None:
            pulumi.set(__self__, "allow_any_name", allow_any_name)
        if allow_bare_domains is not None:
            pulumi.set(__self__, "allow_bare_domains", allow_bare_domains)
        if allow_glob_domains is not None:
            pulumi.set(__self__, "allow_glob_domains", allow_glob_domains)
        if allow_ip_sans is not None:
            pulumi.set(__self__, "allow_ip_sans", allow_ip_sans)
        if allow_localhost is not None:
            pulumi.set(__self__, "allow_localhost", allow_localhost)
        if allow_subdomains is not None:
            pulumi.set(__self__, "allow_subdomains", allow_subdomains)
        if allow_wildcard_certificates is not None:
            pulumi.set(__self__, "allow_wildcard_certificates", allow_wildcard_certificates)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_domains_template is not None:
            pulumi.set(__self__, "allowed_domains_template", allowed_domains_template)
        if allowed_other_sans is not None:
            pulumi.set(__self__, "allowed_other_sans", allowed_other_sans)
        if allowed_secret_groups is not None:
            pulumi.set(__self__, "allowed_secret_groups", allowed_secret_groups)
        if allowed_uri_sans is not None:
            pulumi.set(__self__, "allowed_uri_sans", allowed_uri_sans)
        if basic_constraints_valid_for_non_ca is not None:
            pulumi.set(__self__, "basic_constraints_valid_for_non_ca", basic_constraints_valid_for_non_ca)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_flag is not None:
            pulumi.set(__self__, "client_flag", client_flag)
        if code_signing_flag is not None:
            pulumi.set(__self__, "code_signing_flag", code_signing_flag)
        if config_type is not None:
            pulumi.set(__self__, "config_type", config_type)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if email_protection_flag is not None:
            pulumi.set(__self__, "email_protection_flag", email_protection_flag)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if enforce_hostnames is not None:
            pulumi.set(__self__, "enforce_hostnames", enforce_hostnames)
        if ext_key_usage_oids is not None:
            pulumi.set(__self__, "ext_key_usage_oids", ext_key_usage_oids)
        if ext_key_usages is not None:
            pulumi.set(__self__, "ext_key_usages", ext_key_usages)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_bits is not None:
            pulumi.set(__self__, "key_bits", key_bits)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if key_usages is not None:
            pulumi.set(__self__, "key_usages", key_usages)
        if localities is not None:
            pulumi.set(__self__, "localities", localities)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if max_ttl_seconds is not None:
            pulumi.set(__self__, "max_ttl_seconds", max_ttl_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if not_before_duration is not None:
            pulumi.set(__self__, "not_before_duration", not_before_duration)
        if not_before_duration_seconds is not None:
            pulumi.set(__self__, "not_before_duration_seconds", not_before_duration_seconds)
        if organizations is not None:
            pulumi.set(__self__, "organizations", organizations)
        if ous is not None:
            pulumi.set(__self__, "ous", ous)
        if policy_identifiers is not None:
            pulumi.set(__self__, "policy_identifiers", policy_identifiers)
        if postal_codes is not None:
            pulumi.set(__self__, "postal_codes", postal_codes)
        if provinces is not None:
            pulumi.set(__self__, "provinces", provinces)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if require_cn is not None:
            pulumi.set(__self__, "require_cn", require_cn)
        if secret_type is not None:
            pulumi.set(__self__, "secret_type", secret_type)
        if serial_number is not None:
            warnings.warn("""This field is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""serial_number is deprecated: This field is deprecated.""")
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if server_flag is not None:
            pulumi.set(__self__, "server_flag", server_flag)
        if street_addresses is not None:
            pulumi.set(__self__, "street_addresses", street_addresses)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if use_csr_common_name is not None:
            pulumi.set(__self__, "use_csr_common_name", use_csr_common_name)
        if use_csr_sans is not None:
            pulumi.set(__self__, "use_csr_sans", use_csr_sans)

    @_builtins.property
    @pulumi.getter(name="allowAnyName")
    def allow_any_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request a private certificate that matches any common name.
        """
        return pulumi.get(self, "allow_any_name")

    @allow_any_name.setter
    def allow_any_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_any_name", value)

    @_builtins.property
    @pulumi.getter(name="allowBareDomains")
    def allow_bare_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        """
        return pulumi.get(self, "allow_bare_domains")

    @allow_bare_domains.setter
    def allow_bare_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_bare_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowGlobDomains")
    def allow_glob_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        """
        return pulumi.get(self, "allow_glob_domains")

    @allow_glob_domains.setter
    def allow_glob_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_glob_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowIpSans")
    def allow_ip_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        """
        return pulumi.get(self, "allow_ip_sans")

    @allow_ip_sans.setter
    def allow_ip_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_ip_sans", value)

    @_builtins.property
    @pulumi.getter(name="allowLocalhost")
    def allow_localhost(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow `localhost` to be included as one of the requested common names.
        """
        return pulumi.get(self, "allow_localhost")

    @allow_localhost.setter
    def allow_localhost(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_localhost", value)

    @_builtins.property
    @pulumi.getter(name="allowSubdomains")
    def allow_subdomains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        """
        return pulumi.get(self, "allow_subdomains")

    @allow_subdomains.setter
    def allow_subdomains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="allowWildcardCertificates")
    def allow_wildcard_certificates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        """
        return pulumi.get(self, "allow_wildcard_certificates")

    @allow_wildcard_certificates.setter
    def allow_wildcard_certificates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_wildcard_certificates", value)

    @_builtins.property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowedDomainsTemplate")
    def allowed_domains_template(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        """
        return pulumi.get(self, "allowed_domains_template")

    @allowed_domains_template.setter
    def allowed_domains_template(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allowed_domains_template", value)

    @_builtins.property
    @pulumi.getter(name="allowedOtherSans")
    def allowed_other_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        """
        return pulumi.get(self, "allowed_other_sans")

    @allowed_other_sans.setter
    def allowed_other_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_other_sans", value)

    @_builtins.property
    @pulumi.getter(name="allowedSecretGroups")
    def allowed_secret_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        """
        return pulumi.get(self, "allowed_secret_groups")

    @allowed_secret_groups.setter
    def allowed_secret_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allowed_secret_groups", value)

    @_builtins.property
    @pulumi.getter(name="allowedUriSans")
    def allowed_uri_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        """
        return pulumi.get(self, "allowed_uri_sans")

    @allowed_uri_sans.setter
    def allowed_uri_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_uri_sans", value)

    @_builtins.property
    @pulumi.getter(name="basicConstraintsValidForNonCa")
    def basic_constraints_valid_for_non_ca(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        """
        return pulumi.get(self, "basic_constraints_valid_for_non_ca")

    @basic_constraints_valid_for_non_ca.setter
    def basic_constraints_valid_for_non_ca(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "basic_constraints_valid_for_non_ca", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the intermediate certificate authority.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientFlag")
    def client_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for client use.
        """
        return pulumi.get(self, "client_flag")

    @client_flag.setter
    def client_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "client_flag", value)

    @_builtins.property
    @pulumi.getter(name="codeSigningFlag")
    def code_signing_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for code signing use.
        """
        return pulumi.get(self, "code_signing_flag")

    @code_signing_flag.setter
    def code_signing_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "code_signing_flag", value)

    @_builtins.property
    @pulumi.getter(name="configType")
    def config_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The configuration type.
        """
        return pulumi.get(self, "config_type")

    @config_type.setter
    def config_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_type", value)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Country (C) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "countries", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date when a resource was created. The date format follows RFC 3339.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier that is associated with the entity that created the secret.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="emailProtectionFlag")
    def email_protection_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for email protection use.
        """
        return pulumi.get(self, "email_protection_flag")

    @email_protection_flag.setter
    def email_protection_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "email_protection_flag", value)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        public or private.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="enforceHostnames")
    def enforce_hostnames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        """
        return pulumi.get(self, "enforce_hostnames")

    @enforce_hostnames.setter
    def enforce_hostnames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="extKeyUsageOids")
    def ext_key_usage_oids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of extended key usage Object Identifiers (OIDs).
        """
        return pulumi.get(self, "ext_key_usage_oids")

    @ext_key_usage_oids.setter
    def ext_key_usage_oids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ext_key_usage_oids", value)

    @_builtins.property
    @pulumi.getter(name="extKeyUsages")
    def ext_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "ext_key_usages")

    @ext_key_usages.setter
    def ext_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ext_key_usages", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Secrets Manager instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="keyBits")
    def key_bits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        """
        return pulumi.get(self, "key_bits")

    @key_bits.setter
    def key_bits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_bits", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of private key to generate.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="keyUsages")
    def key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "key_usages")

    @key_usages.setter
    def key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_usages", value)

    @_builtins.property
    @pulumi.getter
    def localities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Locality (L) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "localities")

    @localities.setter
    def localities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "localities", value)

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        """
        return pulumi.get(self, "max_ttl")

    @max_ttl.setter
    def max_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_ttl", value)

    @_builtins.property
    @pulumi.getter(name="maxTtlSeconds")
    def max_ttl_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
        """
        return pulumi.get(self, "max_ttl_seconds")

    @max_ttl_seconds.setter
    def max_ttl_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ttl_seconds", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="notBeforeDuration")
    def not_before_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "not_before_duration")

    @not_before_duration.setter
    def not_before_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_before_duration", value)

    @_builtins.property
    @pulumi.getter(name="notBeforeDurationSeconds")
    def not_before_duration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in seconds by which to backdate the `not_before` property of an issued private certificate.
        """
        return pulumi.get(self, "not_before_duration_seconds")

    @not_before_duration_seconds.setter
    def not_before_duration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "not_before_duration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Organization (O) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "organizations")

    @organizations.setter
    def organizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "organizations", value)

    @_builtins.property
    @pulumi.getter
    def ous(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "ous")

    @ous.setter
    def ous(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ous", value)

    @_builtins.property
    @pulumi.getter(name="policyIdentifiers")
    def policy_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of policy Object Identifiers (OIDs).
        """
        return pulumi.get(self, "policy_identifiers")

    @policy_identifiers.setter
    def policy_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_identifiers", value)

    @_builtins.property
    @pulumi.getter(name="postalCodes")
    def postal_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The postal code values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "postal_codes")

    @postal_codes.setter
    def postal_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "postal_codes", value)

    @_builtins.property
    @pulumi.getter
    def provinces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Province (ST) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "provinces")

    @provinces.setter
    def provinces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "provinces", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the Secrets Manager instance.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="requireCn")
    def require_cn(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        """
        return pulumi.get(self, "require_cn")

    @require_cn.setter
    def require_cn(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_cn", value)

    @_builtins.property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_type", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    @_utilities.deprecated("""This field is deprecated.""")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unused field.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="serverFlag")
    def server_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether private certificates are flagged for server use.
        """
        return pulumi.get(self, "server_flag")

    @server_flag.setter
    def server_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_flag", value)

    @_builtins.property
    @pulumi.getter(name="streetAddresses")
    def street_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The street address values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "street_addresses")

    @street_addresses.setter
    def street_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "street_addresses", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The requested Time To Live, after which the certificate will be expired.
        """
        return pulumi.get(self, "ttl_seconds")

    @ttl_seconds.setter
    def ttl_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl_seconds", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date when a resource was recently modified. The date format follows RFC 3339.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="useCsrCommonName")
    def use_csr_common_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        """
        return pulumi.get(self, "use_csr_common_name")

    @use_csr_common_name.setter
    def use_csr_common_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_csr_common_name", value)

    @_builtins.property
    @pulumi.getter(name="useCsrSans")
    def use_csr_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        return pulumi.get(self, "use_csr_sans")

    @use_csr_sans.setter
    def use_csr_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_csr_sans", value)


@pulumi.type_token("ibmcloud:index/smPrivateCertificateConfigurationTemplate:SmPrivateCertificateConfigurationTemplate")
class SmPrivateCertificateConfigurationTemplate(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_any_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_bare_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_glob_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_ip_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_localhost: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_wildcard_certificates: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_domains_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_secret_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 allowed_uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 basic_constraints_valid_for_non_ca: Optional[pulumi.Input[_builtins.bool]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 code_signing_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_protection_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_hostnames: Optional[pulumi.Input[_builtins.bool]] = None,
                 ext_key_usage_oids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ext_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_bits: Optional[pulumi.Input[_builtins.int]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 localities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 organizations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ous: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policy_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 postal_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provinces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 require_cn: Optional[pulumi.Input[_builtins.bool]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 server_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 street_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 use_csr_common_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_csr_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        """
        Create a SmPrivateCertificateConfigurationTemplate resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] allow_any_name: Determines whether to allow clients to request a private certificate that matches any common name.
        :param pulumi.Input[_builtins.bool] allow_bare_domains: Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        :param pulumi.Input[_builtins.bool] allow_glob_domains: Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        :param pulumi.Input[_builtins.bool] allow_ip_sans: Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        :param pulumi.Input[_builtins.bool] allow_localhost: Determines whether to allow `localhost` to be included as one of the requested common names.
        :param pulumi.Input[_builtins.bool] allow_subdomains: Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        :param pulumi.Input[_builtins.bool] allow_wildcard_certificates: Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_domains: The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        :param pulumi.Input[_builtins.bool] allowed_domains_template: Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_other_sans: The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        :param pulumi.Input[_builtins.str] allowed_secret_groups: Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_uri_sans: The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        :param pulumi.Input[_builtins.bool] basic_constraints_valid_for_non_ca: Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        :param pulumi.Input[_builtins.str] certificate_authority: The name of the intermediate certificate authority.
        :param pulumi.Input[_builtins.bool] client_flag: Determines whether private certificates are flagged for client use.
        :param pulumi.Input[_builtins.bool] code_signing_flag: Determines whether private certificates are flagged for code signing use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] countries: The Country (C) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.bool] email_protection_flag: Determines whether private certificates are flagged for email protection use.
        :param pulumi.Input[_builtins.str] endpoint_type: public or private.
        :param pulumi.Input[_builtins.bool] enforce_hostnames: Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usage_oids: A list of extended key usage Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usages: The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[_builtins.str] instance_id: The ID of the Secrets Manager instance.
        :param pulumi.Input[_builtins.int] key_bits: The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        :param pulumi.Input[_builtins.str] key_type: The type of private key to generate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_usages: The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] localities: The Locality (L) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] max_ttl: The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param pulumi.Input[_builtins.str] name: A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        :param pulumi.Input[_builtins.str] not_before_duration: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] organizations: The Organization (O) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ous: The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_identifiers: A list of policy Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] postal_codes: The postal code values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] provinces: The Province (ST) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] region: The region of the Secrets Manager instance.
        :param pulumi.Input[_builtins.bool] require_cn: Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        :param pulumi.Input[_builtins.str] serial_number: Unused field.
        :param pulumi.Input[_builtins.bool] server_flag: Determines whether private certificates are flagged for server use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] street_addresses: The street address values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] ttl: The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.bool] use_csr_common_name: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        :param pulumi.Input[_builtins.bool] use_csr_sans: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: SmPrivateCertificateConfigurationTemplateArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a SmPrivateCertificateConfigurationTemplate resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param SmPrivateCertificateConfigurationTemplateArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(SmPrivateCertificateConfigurationTemplateArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_any_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_bare_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_glob_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_ip_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_localhost: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_wildcard_certificates: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_domains_template: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_secret_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 allowed_uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 basic_constraints_valid_for_non_ca: Optional[pulumi.Input[_builtins.bool]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 code_signing_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_protection_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_hostnames: Optional[pulumi.Input[_builtins.bool]] = None,
                 ext_key_usage_oids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ext_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_bits: Optional[pulumi.Input[_builtins.int]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 localities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 organizations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ous: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 policy_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 postal_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provinces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 require_cn: Optional[pulumi.Input[_builtins.bool]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 server_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 street_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 use_csr_common_name: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_csr_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = SmPrivateCertificateConfigurationTemplateArgs.__new__(SmPrivateCertificateConfigurationTemplateArgs)

            __props__.__dict__["allow_any_name"] = allow_any_name
            __props__.__dict__["allow_bare_domains"] = allow_bare_domains
            __props__.__dict__["allow_glob_domains"] = allow_glob_domains
            __props__.__dict__["allow_ip_sans"] = allow_ip_sans
            __props__.__dict__["allow_localhost"] = allow_localhost
            __props__.__dict__["allow_subdomains"] = allow_subdomains
            __props__.__dict__["allow_wildcard_certificates"] = allow_wildcard_certificates
            __props__.__dict__["allowed_domains"] = allowed_domains
            __props__.__dict__["allowed_domains_template"] = allowed_domains_template
            __props__.__dict__["allowed_other_sans"] = allowed_other_sans
            __props__.__dict__["allowed_secret_groups"] = allowed_secret_groups
            __props__.__dict__["allowed_uri_sans"] = allowed_uri_sans
            __props__.__dict__["basic_constraints_valid_for_non_ca"] = basic_constraints_valid_for_non_ca
            if certificate_authority is None and not opts.urn:
                raise TypeError("Missing required property 'certificate_authority'")
            __props__.__dict__["certificate_authority"] = certificate_authority
            __props__.__dict__["client_flag"] = client_flag
            __props__.__dict__["code_signing_flag"] = code_signing_flag
            __props__.__dict__["countries"] = countries
            __props__.__dict__["email_protection_flag"] = email_protection_flag
            __props__.__dict__["endpoint_type"] = endpoint_type
            __props__.__dict__["enforce_hostnames"] = enforce_hostnames
            __props__.__dict__["ext_key_usage_oids"] = ext_key_usage_oids
            __props__.__dict__["ext_key_usages"] = ext_key_usages
            if instance_id is None and not opts.urn:
                raise TypeError("Missing required property 'instance_id'")
            __props__.__dict__["instance_id"] = instance_id
            __props__.__dict__["key_bits"] = key_bits
            __props__.__dict__["key_type"] = key_type
            __props__.__dict__["key_usages"] = key_usages
            __props__.__dict__["localities"] = localities
            __props__.__dict__["max_ttl"] = max_ttl
            __props__.__dict__["name"] = name
            __props__.__dict__["not_before_duration"] = not_before_duration
            __props__.__dict__["organizations"] = organizations
            __props__.__dict__["ous"] = ous
            __props__.__dict__["policy_identifiers"] = policy_identifiers
            __props__.__dict__["postal_codes"] = postal_codes
            __props__.__dict__["provinces"] = provinces
            __props__.__dict__["region"] = region
            __props__.__dict__["require_cn"] = require_cn
            __props__.__dict__["serial_number"] = serial_number
            __props__.__dict__["server_flag"] = server_flag
            __props__.__dict__["street_addresses"] = street_addresses
            __props__.__dict__["ttl"] = ttl
            __props__.__dict__["use_csr_common_name"] = use_csr_common_name
            __props__.__dict__["use_csr_sans"] = use_csr_sans
            __props__.__dict__["config_type"] = None
            __props__.__dict__["created_at"] = None
            __props__.__dict__["created_by"] = None
            __props__.__dict__["max_ttl_seconds"] = None
            __props__.__dict__["not_before_duration_seconds"] = None
            __props__.__dict__["secret_type"] = None
            __props__.__dict__["ttl_seconds"] = None
            __props__.__dict__["updated_at"] = None
        super(SmPrivateCertificateConfigurationTemplate, __self__).__init__(
            'ibmcloud:index/smPrivateCertificateConfigurationTemplate:SmPrivateCertificateConfigurationTemplate',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allow_any_name: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_bare_domains: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_glob_domains: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_ip_sans: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_localhost: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
            allow_wildcard_certificates: Optional[pulumi.Input[_builtins.bool]] = None,
            allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            allowed_domains_template: Optional[pulumi.Input[_builtins.bool]] = None,
            allowed_other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            allowed_secret_groups: Optional[pulumi.Input[_builtins.str]] = None,
            allowed_uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            basic_constraints_valid_for_non_ca: Optional[pulumi.Input[_builtins.bool]] = None,
            certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
            client_flag: Optional[pulumi.Input[_builtins.bool]] = None,
            code_signing_flag: Optional[pulumi.Input[_builtins.bool]] = None,
            config_type: Optional[pulumi.Input[_builtins.str]] = None,
            countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            created_at: Optional[pulumi.Input[_builtins.str]] = None,
            created_by: Optional[pulumi.Input[_builtins.str]] = None,
            email_protection_flag: Optional[pulumi.Input[_builtins.bool]] = None,
            endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
            enforce_hostnames: Optional[pulumi.Input[_builtins.bool]] = None,
            ext_key_usage_oids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            ext_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            instance_id: Optional[pulumi.Input[_builtins.str]] = None,
            key_bits: Optional[pulumi.Input[_builtins.int]] = None,
            key_type: Optional[pulumi.Input[_builtins.str]] = None,
            key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            localities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            max_ttl: Optional[pulumi.Input[_builtins.str]] = None,
            max_ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            not_before_duration: Optional[pulumi.Input[_builtins.str]] = None,
            not_before_duration_seconds: Optional[pulumi.Input[_builtins.int]] = None,
            organizations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            ous: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            policy_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            postal_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            provinces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            require_cn: Optional[pulumi.Input[_builtins.bool]] = None,
            secret_type: Optional[pulumi.Input[_builtins.str]] = None,
            serial_number: Optional[pulumi.Input[_builtins.str]] = None,
            server_flag: Optional[pulumi.Input[_builtins.bool]] = None,
            street_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            ttl: Optional[pulumi.Input[_builtins.str]] = None,
            ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
            updated_at: Optional[pulumi.Input[_builtins.str]] = None,
            use_csr_common_name: Optional[pulumi.Input[_builtins.bool]] = None,
            use_csr_sans: Optional[pulumi.Input[_builtins.bool]] = None) -> 'SmPrivateCertificateConfigurationTemplate':
        """
        Get an existing SmPrivateCertificateConfigurationTemplate resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] allow_any_name: Determines whether to allow clients to request a private certificate that matches any common name.
        :param pulumi.Input[_builtins.bool] allow_bare_domains: Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        :param pulumi.Input[_builtins.bool] allow_glob_domains: Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        :param pulumi.Input[_builtins.bool] allow_ip_sans: Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        :param pulumi.Input[_builtins.bool] allow_localhost: Determines whether to allow `localhost` to be included as one of the requested common names.
        :param pulumi.Input[_builtins.bool] allow_subdomains: Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        :param pulumi.Input[_builtins.bool] allow_wildcard_certificates: Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_domains: The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        :param pulumi.Input[_builtins.bool] allowed_domains_template: Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_other_sans: The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        :param pulumi.Input[_builtins.str] allowed_secret_groups: Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_uri_sans: The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        :param pulumi.Input[_builtins.bool] basic_constraints_valid_for_non_ca: Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        :param pulumi.Input[_builtins.str] certificate_authority: The name of the intermediate certificate authority.
        :param pulumi.Input[_builtins.bool] client_flag: Determines whether private certificates are flagged for client use.
        :param pulumi.Input[_builtins.bool] code_signing_flag: Determines whether private certificates are flagged for code signing use.
        :param pulumi.Input[_builtins.str] config_type: The configuration type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] countries: The Country (C) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] created_at: The date when a resource was created. The date format follows RFC 3339.
        :param pulumi.Input[_builtins.str] created_by: The unique identifier that is associated with the entity that created the secret.
        :param pulumi.Input[_builtins.bool] email_protection_flag: Determines whether private certificates are flagged for email protection use.
        :param pulumi.Input[_builtins.str] endpoint_type: public or private.
        :param pulumi.Input[_builtins.bool] enforce_hostnames: Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usage_oids: A list of extended key usage Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ext_key_usages: The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[_builtins.str] instance_id: The ID of the Secrets Manager instance.
        :param pulumi.Input[_builtins.int] key_bits: The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        :param pulumi.Input[_builtins.str] key_type: The type of private key to generate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_usages: The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] localities: The Locality (L) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] max_ttl: The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param pulumi.Input[_builtins.int] max_ttl_seconds: The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
        :param pulumi.Input[_builtins.str] name: A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        :param pulumi.Input[_builtins.str] not_before_duration: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.int] not_before_duration_seconds: The duration in seconds by which to backdate the `not_before` property of an issued private certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] organizations: The Organization (O) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ous: The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_identifiers: A list of policy Object Identifiers (OIDs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] postal_codes: The postal code values to define in the subject field of the resulting certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] provinces: The Province (ST) values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] region: The region of the Secrets Manager instance.
        :param pulumi.Input[_builtins.bool] require_cn: Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        :param pulumi.Input[_builtins.str] secret_type: The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
        :param pulumi.Input[_builtins.str] serial_number: Unused field.
        :param pulumi.Input[_builtins.bool] server_flag: Determines whether private certificates are flagged for server use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] street_addresses: The street address values to define in the subject field of the resulting certificate.
        :param pulumi.Input[_builtins.str] ttl: The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        :param pulumi.Input[_builtins.int] ttl_seconds: The requested Time To Live, after which the certificate will be expired.
        :param pulumi.Input[_builtins.str] updated_at: The date when a resource was recently modified. The date format follows RFC 3339.
        :param pulumi.Input[_builtins.bool] use_csr_common_name: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        :param pulumi.Input[_builtins.bool] use_csr_sans: When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _SmPrivateCertificateConfigurationTemplateState.__new__(_SmPrivateCertificateConfigurationTemplateState)

        __props__.__dict__["allow_any_name"] = allow_any_name
        __props__.__dict__["allow_bare_domains"] = allow_bare_domains
        __props__.__dict__["allow_glob_domains"] = allow_glob_domains
        __props__.__dict__["allow_ip_sans"] = allow_ip_sans
        __props__.__dict__["allow_localhost"] = allow_localhost
        __props__.__dict__["allow_subdomains"] = allow_subdomains
        __props__.__dict__["allow_wildcard_certificates"] = allow_wildcard_certificates
        __props__.__dict__["allowed_domains"] = allowed_domains
        __props__.__dict__["allowed_domains_template"] = allowed_domains_template
        __props__.__dict__["allowed_other_sans"] = allowed_other_sans
        __props__.__dict__["allowed_secret_groups"] = allowed_secret_groups
        __props__.__dict__["allowed_uri_sans"] = allowed_uri_sans
        __props__.__dict__["basic_constraints_valid_for_non_ca"] = basic_constraints_valid_for_non_ca
        __props__.__dict__["certificate_authority"] = certificate_authority
        __props__.__dict__["client_flag"] = client_flag
        __props__.__dict__["code_signing_flag"] = code_signing_flag
        __props__.__dict__["config_type"] = config_type
        __props__.__dict__["countries"] = countries
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["created_by"] = created_by
        __props__.__dict__["email_protection_flag"] = email_protection_flag
        __props__.__dict__["endpoint_type"] = endpoint_type
        __props__.__dict__["enforce_hostnames"] = enforce_hostnames
        __props__.__dict__["ext_key_usage_oids"] = ext_key_usage_oids
        __props__.__dict__["ext_key_usages"] = ext_key_usages
        __props__.__dict__["instance_id"] = instance_id
        __props__.__dict__["key_bits"] = key_bits
        __props__.__dict__["key_type"] = key_type
        __props__.__dict__["key_usages"] = key_usages
        __props__.__dict__["localities"] = localities
        __props__.__dict__["max_ttl"] = max_ttl
        __props__.__dict__["max_ttl_seconds"] = max_ttl_seconds
        __props__.__dict__["name"] = name
        __props__.__dict__["not_before_duration"] = not_before_duration
        __props__.__dict__["not_before_duration_seconds"] = not_before_duration_seconds
        __props__.__dict__["organizations"] = organizations
        __props__.__dict__["ous"] = ous
        __props__.__dict__["policy_identifiers"] = policy_identifiers
        __props__.__dict__["postal_codes"] = postal_codes
        __props__.__dict__["provinces"] = provinces
        __props__.__dict__["region"] = region
        __props__.__dict__["require_cn"] = require_cn
        __props__.__dict__["secret_type"] = secret_type
        __props__.__dict__["serial_number"] = serial_number
        __props__.__dict__["server_flag"] = server_flag
        __props__.__dict__["street_addresses"] = street_addresses
        __props__.__dict__["ttl"] = ttl
        __props__.__dict__["ttl_seconds"] = ttl_seconds
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["use_csr_common_name"] = use_csr_common_name
        __props__.__dict__["use_csr_sans"] = use_csr_sans
        return SmPrivateCertificateConfigurationTemplate(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="allowAnyName")
    def allow_any_name(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow clients to request a private certificate that matches any common name.
        """
        return pulumi.get(self, "allow_any_name")

    @_builtins.property
    @pulumi.getter(name="allowBareDomains")
    def allow_bare_domains(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow clients to request private certificates that match the value of the actual domains on the final certificate.For example, if you specify `example.com` in the `allowed_domains` field, you grant clients the ability to request a certificate that contains the name `example.com` as one of the DNS values on the final certificate.**Important:** In some scenarios, allowing bare domains can be considered a security risk.
        """
        return pulumi.get(self, "allow_bare_domains")

    @_builtins.property
    @pulumi.getter(name="allowGlobDomains")
    def allow_glob_domains(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow glob patterns, for example, `ftp*.example.com`, in the names that are specified in the `allowed_domains` field.If set to `true`, clients are allowed to request private certificates with names that match the glob patterns.
        """
        return pulumi.get(self, "allow_glob_domains")

    @_builtins.property
    @pulumi.getter(name="allowIpSans")
    def allow_ip_sans(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow clients to request a private certificate with IP Subject Alternative Names.
        """
        return pulumi.get(self, "allow_ip_sans")

    @_builtins.property
    @pulumi.getter(name="allowLocalhost")
    def allow_localhost(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow `localhost` to be included as one of the requested common names.
        """
        return pulumi.get(self, "allow_localhost")

    @_builtins.property
    @pulumi.getter(name="allowSubdomains")
    def allow_subdomains(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow clients to request private certificates with common names (CN) that are subdomains of the CNs that are allowed by the other certificate template options. This includes wildcard subdomains.For example, if `allowed_domains` has a value of `example.com` and `allow_subdomains`is set to `true`, then the following subdomains are allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.**Note:** This field is redundant if you use the `allow_any_name` option.
        """
        return pulumi.get(self, "allow_subdomains")

    @_builtins.property
    @pulumi.getter(name="allowWildcardCertificates")
    def allow_wildcard_certificates(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether the issuance of certificates with RFC 6125 wildcards in the CN field.When set to false, this field prevents wildcards from being issued even if they can be allowed by an option `allow_glob_domains`.
        """
        return pulumi.get(self, "allow_wildcard_certificates")

    @_builtins.property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The domains to define for the certificate template. This property is used along with the `allow_bare_domains` and `allow_subdomains` options.
        """
        return pulumi.get(self, "allowed_domains")

    @_builtins.property
    @pulumi.getter(name="allowedDomainsTemplate")
    def allowed_domains_template(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to allow the domains that are supplied in the `allowed_domains` field to contain access control list (ACL) templates.
        """
        return pulumi.get(self, "allowed_domains_template")

    @_builtins.property
    @pulumi.getter(name="allowedOtherSans")
    def allowed_other_sans(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The custom Object Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private certificates.The format for each element in the list is the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any value for an OID, use `*` as its value. Alternatively, specify a single `*` to allow any `other_sans` input.
        """
        return pulumi.get(self, "allowed_other_sans")

    @_builtins.property
    @pulumi.getter(name="allowedSecretGroups")
    def allowed_secret_groups(self) -> pulumi.Output[_builtins.str]:
        """
        Scopes the creation of private certificates to only the secret groups that you specify.This field can be supplied as a comma-delimited list of secret group IDs.
        """
        return pulumi.get(self, "allowed_secret_groups")

    @_builtins.property
    @pulumi.getter(name="allowedUriSans")
    def allowed_uri_sans(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The URI Subject Alternative Names to allow for private certificates.Values can contain glob patterns, for example `spiffe://hostname/_*`.
        """
        return pulumi.get(self, "allowed_uri_sans")

    @_builtins.property
    @pulumi.getter(name="basicConstraintsValidForNonCa")
    def basic_constraints_valid_for_non_ca(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to mark the Basic Constraints extension of an issued private certificate as valid for non-CA certificates.
        """
        return pulumi.get(self, "basic_constraints_valid_for_non_ca")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the intermediate certificate authority.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientFlag")
    def client_flag(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether private certificates are flagged for client use.
        """
        return pulumi.get(self, "client_flag")

    @_builtins.property
    @pulumi.getter(name="codeSigningFlag")
    def code_signing_flag(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether private certificates are flagged for code signing use.
        """
        return pulumi.get(self, "code_signing_flag")

    @_builtins.property
    @pulumi.getter(name="configType")
    def config_type(self) -> pulumi.Output[_builtins.str]:
        """
        The configuration type.
        """
        return pulumi.get(self, "config_type")

    @_builtins.property
    @pulumi.getter
    def countries(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The Country (C) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "countries")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[_builtins.str]:
        """
        The date when a resource was created. The date format follows RFC 3339.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> pulumi.Output[_builtins.str]:
        """
        The unique identifier that is associated with the entity that created the secret.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="emailProtectionFlag")
    def email_protection_flag(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether private certificates are flagged for email protection use.
        """
        return pulumi.get(self, "email_protection_flag")

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        public or private.
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="enforceHostnames")
    def enforce_hostnames(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to enforce only valid host names for common names, DNS Subject Alternative Names, and the host section of email addresses.
        """
        return pulumi.get(self, "enforce_hostnames")

    @_builtins.property
    @pulumi.getter(name="extKeyUsageOids")
    def ext_key_usage_oids(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        A list of extended key usage Object Identifiers (OIDs).
        """
        return pulumi.get(self, "ext_key_usage_oids")

    @_builtins.property
    @pulumi.getter(name="extKeyUsages")
    def ext_key_usages(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The allowed extended key usage constraint on private certificates.You can find valid values in the [Go x509 package documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "ext_key_usages")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Output[_builtins.str]:
        """
        The ID of the Secrets Manager instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="keyBits")
    def key_bits(self) -> pulumi.Output[_builtins.int]:
        """
        The number of bits to use to generate the private key.Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`. The default for EC keys is `256`.
        """
        return pulumi.get(self, "key_bits")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Output[_builtins.str]:
        """
        The type of private key to generate.
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter(name="keyUsages")
    def key_usages(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The allowed key usage constraint to define for private certificates.You can find valid values in the [Go x509 package documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage` part of the value. Values are not case-sensitive. To specify no key usage constraints, set this field to an empty list.
        """
        return pulumi.get(self, "key_usages")

    @_builtins.property
    @pulumi.getter
    def localities(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The Locality (L) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "localities")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The maximum time-to-live (TTL) for certificates that are created by this CA.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtlSeconds")
    def max_ttl_seconds(self) -> pulumi.Output[_builtins.int]:
        """
        The maximum time-to-live (TTL) for certificates that are created by this CA in seconds.
        """
        return pulumi.get(self, "max_ttl_seconds")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        A human-readable unique name to assign to your configuration.To protect your privacy, do not use personal data, such as your name or location, as an name for your secret.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notBeforeDuration")
    def not_before_duration(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The duration in seconds by which to backdate the `not_before` property of an issued private certificate.The value can be supplied as a string representation of a duration, such as `30s`. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "not_before_duration")

    @_builtins.property
    @pulumi.getter(name="notBeforeDurationSeconds")
    def not_before_duration_seconds(self) -> pulumi.Output[_builtins.int]:
        """
        The duration in seconds by which to backdate the `not_before` property of an issued private certificate.
        """
        return pulumi.get(self, "not_before_duration_seconds")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The Organization (O) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "organizations")

    @_builtins.property
    @pulumi.getter
    def ous(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The Organizational Unit (OU) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "ous")

    @_builtins.property
    @pulumi.getter(name="policyIdentifiers")
    def policy_identifiers(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        A list of policy Object Identifiers (OIDs).
        """
        return pulumi.get(self, "policy_identifiers")

    @_builtins.property
    @pulumi.getter(name="postalCodes")
    def postal_codes(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The postal code values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "postal_codes")

    @_builtins.property
    @pulumi.getter
    def provinces(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The Province (ST) values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "provinces")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[_builtins.str]:
        """
        The region of the Secrets Manager instance.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="requireCn")
    def require_cn(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether to require a common name to create a private certificate.By default, a common name is required to generate a certificate. To make the `common_name` field optional, set the `require_cn` option to `false`.
        """
        return pulumi.get(self, "require_cn")

    @_builtins.property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> pulumi.Output[_builtins.str]:
        """
        The secret type. Supported types are arbitrary, certificates (imported, public, and private), IAM credentials, key-value, and user credentials.
        """
        return pulumi.get(self, "secret_type")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    @_utilities.deprecated("""This field is deprecated.""")
    def serial_number(self) -> pulumi.Output[_builtins.str]:
        """
        Unused field.
        """
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter(name="serverFlag")
    def server_flag(self) -> pulumi.Output[_builtins.bool]:
        """
        Determines whether private certificates are flagged for server use.
        """
        return pulumi.get(self, "server_flag")

    @_builtins.property
    @pulumi.getter(name="streetAddresses")
    def street_addresses(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        The street address values to define in the subject field of the resulting certificate.
        """
        return pulumi.get(self, "street_addresses")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The requested time-to-live (TTL) for certificates that are created by this CA. This field's value cannot be longer than the `max_ttl` limit.The value can be supplied as a string representation of a duration in hours, for example '8760h'. In the API response, this value is returned in seconds (integer).
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> pulumi.Output[_builtins.int]:
        """
        The requested Time To Live, after which the certificate will be expired.
        """
        return pulumi.get(self, "ttl_seconds")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[_builtins.str]:
        """
        The date when a resource was recently modified. The date format follows RFC 3339.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="useCsrCommonName")
    def use_csr_common_name(self) -> pulumi.Output[_builtins.bool]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the common name (CN) from a certificate signing request (CSR) instead of the CN that's included in the data of the certificate.Does not include any requested Subject Alternative Names (SANs) in the CSR. To use the alternative names, include the `use_csr_sans` property.
        """
        return pulumi.get(self, "use_csr_common_name")

    @_builtins.property
    @pulumi.getter(name="useCsrSans")
    def use_csr_sans(self) -> pulumi.Output[_builtins.bool]:
        """
        When used with the `private_cert_configuration_action_sign_csr` action, this field determines whether to use the Subject Alternative Names(SANs) from a certificate signing request (CSR) instead of the SANs that are included in the data of the certificate.Does not include the common name in the CSR. To use the common name, include the `use_csr_common_name` property.
        """
        return pulumi.get(self, "use_csr_sans")

